"use strict";(self.webpackChunkmomento_docs=self.webpackChunkmomento_docs||[]).push([[5261],{44902:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=n(74848),i=n(28453);const a={sidebar_position:2,sidebar_label:"Real-time updates",title:"Real-time entitlement updates",description:"Learn how to keep entitlements in sync across all your media players",hide_title:!0,keywords:["momento","media storage","zero buffer rate","zbr","streaming","live","elemental","serverless","metrics","entitlements"]},r="Making real-time updates to entitlements",o={id:"media-storage/entitlements/real-time-updates",title:"Real-time entitlement updates",description:"Learn how to keep entitlements in sync across all your media players",source:"@site/docs/media-storage/entitlements/real-time-updates.md",sourceDirName:"media-storage/entitlements",slug:"/media-storage/entitlements/real-time-updates",permalink:"/ja/media-storage/entitlements/real-time-updates",draft:!1,unlisted:!1,editUrl:"https://github.com/momentohq/public-dev-docs/tree/main/docs/media-storage/entitlements/real-time-updates.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Real-time updates",title:"Real-time entitlement updates",description:"Learn how to keep entitlements in sync across all your media players",hide_title:!0,keywords:["momento","media storage","zero buffer rate","zbr","streaming","live","elemental","serverless","metrics","entitlements"]},sidebar:"mediastorageSidebar",previous:{title:"About",permalink:"/ja/media-storage/entitlements/about"},next:{title:"Insights and Control"}},l={},c=[{value:"1. Entitlements are calculated and sent to the media player",id:"1-entitlements-are-calculated-and-sent-to-the-media-player",level:2},{value:"2. Fetch entitlements and subscribe for updates",id:"2-fetch-entitlements-and-subscribe-for-updates",level:2},{value:"3. Update entitlements and notify",id:"3-update-entitlements-and-notify",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"making-real-time-updates-to-entitlements",children:"Making real-time updates to entitlements"})}),"\n",(0,s.jsxs)(t.p,{children:["When users purchase a subscription, you need to make new content immediately accessible. But if ",(0,s.jsx)(t.a,{href:"/media-storage/entitlements/about",children:"entitlements"})," are cached on client-side players, how do you invalidate it efficiently?"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/topics",children:"Momento Topics"})," is a high-performance pub/sub service accessible from anywhere with tight security controls built in. When entitlements change, a message can be published to a topic to notify players of the update so they can respond immediately."]}),"\n",(0,s.jsx)(t.p,{children:"Let's take an example of a user who starts watching free tier content, but decides to upgrade her account to premium."}),"\n",(0,s.jsx)(t.h2,{id:"1-entitlements-are-calculated-and-sent-to-the-media-player",children:"1. Entitlements are calculated and sent to the media player"}),"\n",(0,s.jsx)(t.p,{children:"Whenever the user logs in, the server calculates her entitlements, saves them in the cache, generated a session token unique for her, and passes it down to the browser making the request."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const loginHandler = async (req, res) => {\n  const { userId } = req.claims;\n  const entitlements = calculateEntitlements(userId);\n  await cacheClient.set(NAMESPACE, userId, JSON.stringify(entitlements));\n\n  const scope = {\n    permissions: [{\n      role: 'readonly',\n      cache: NAMESPACE,\n      item: {\n        key: userId\n      }\n    },\n    {\n      role: 'subscribeonly',\n      cache: NAMESPACE,\n      topic: userId\n    }]\n  };\n\n  const tokenResponse = await authClient.generateDisposableToken(scope, ExpiresIn.hours(1), { tokenId: userId }):\n  res.status(200).json({ token: tokenResponse.authToken, userId }):\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"The generated token allows the caller to read the entitlements object in the cache and to subscribe to a topic specific to the user."}),"\n",(0,s.jsx)(t.h2,{id:"2-fetch-entitlements-and-subscribe-for-updates",children:"2. Fetch entitlements and subscribe for updates"}),"\n",(0,s.jsx)(t.p,{children:"The user's browser now has a token that allows her to get what she needs to view free tier content and subscribe for updates if the entitlements change. Below is an excerpt of the code running in the browser (this could be a web page or in a media player component)."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"// Call the loginHandler from the first step\nconst data = await login();\ncacheClient = new CacheClient({ defaultTtlSeconds: 60, credentialProvider: CredentialProvider.fromString(data.token)}):\ntopicClient = new TopicClient({ credentialProvider: CredentialProvider.fromString(data.token)});\n\nawait topicClient.subscribe(NAMESPACE, data.userId, {\n  onItem: (message) => updateEntitlements(data.userId)\n});\n\nupdateEntitlements(data.userId);\n\nfunction updateEntitlements(userId) {\n  const entitlementsResponse = await cacheClient.get(NAMESPACE, userId):\n\n  // set globally scoped entitlements object\n  entitlements = entitlementsResponse.value();\n  displayAvailableMedia();\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Here, the browser is initializing both a Momento CacheClient and TopicClient with the token returned from the login API call. After the clients are created, it subscribes to the user-specific topic and fetches the entitlements out of the cache."}),"\n",(0,s.jsx)(t.p,{children:"Whenever a message is received on the user topic, it calls a function to refresh the entitlements from the cache."}),"\n",(0,s.jsx)(t.h2,{id:"3-update-entitlements-and-notify",children:"3. Update entitlements and notify"}),"\n",(0,s.jsx)(t.p,{children:"After watching a few videos, the user decides she would like to become a premium tier member. She goes through the checkout process and post checkout, the following code runs."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"\nconst updateEntitlements = async (userId) => {\n  // Do business logic to recalculate entitlements\n  const newEntitlements = calculate(userId);\n\n  await cacheClient.set(NAMESPACE, userId, JSON.stringify(newEntitlements));\n  await topicClient.publish(NAMESPACE, userId, JSON.stringify(newEntitlements))\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"This code snippet runs some business logic to recalculate what the entitlements look like, then store the updated object in the cache. After the entitlements are updated, it publishes a message to the user-specific topic containing the updated entitlements."}),"\n",(0,s.jsx)(t.p,{children:"This will signal to the connected browser to refresh the entitlements it has with the data out of Momento Cache, making sure it is immediately up to date with the changes. No additional work needs to be done! It's as easy as that!"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(96540);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);