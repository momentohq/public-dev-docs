"use strict";(globalThis.webpackChunkmomento_docs=globalThis.webpackChunkmomento_docs||[]).push([[6246],{1136:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>d,default:()=>f,frontMatter:()=>u,metadata:()=>a,toc:()=>m});const a=JSON.parse('{"id":"cache/how-to/rate-limiter","title":"Implement a distributed rate-limiter using Momento","description":"Learn how you can implement a distributed rate-limiter using a centralized backend source, Momento.","source":"@site/docs/cache/how-to/rate-limiter.mdx","sourceDirName":"cache/how-to","slug":"/cache/how-to/rate-limiter","permalink":"/cache/how-to/rate-limiter","draft":false,"unlisted":false,"editUrl":"https://github.com/momentohq/public-dev-docs/tree/main/docs/cache/how-to/rate-limiter.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Build a Rate-Limiter","title":"Implement a distributed rate-limiter using Momento","description":"Learn how you can implement a distributed rate-limiter using a centralized backend source, Momento."},"sidebar":"cacheSidebar","previous":{"title":"How To"},"next":{"title":"Patterns"}}');var i=n(74848),r=n(28453);n(42821),n(70503),n(96540);var s=n(11470),l=n(19365),o=n(83457);const c=({js:e,python:t,java:n,kotlin:a,go:r,csharp:c,php:u,rust:d,ruby:h,elixir:m,swift:p,dart:f,cli:g})=>e||t||n||a||r||c||u||d||h||m||p||f||g?(0,i.jsxs)(s.A,{children:[e&&(0,i.jsx)(l.A,{value:"js",label:"JavaScript",children:(0,i.jsx)(o.default,{language:"js",children:e})}),t&&(0,i.jsx)(l.A,{value:"python",label:"Python",children:(0,i.jsx)(o.default,{language:"python",children:t})}),n&&(0,i.jsx)(l.A,{value:"java",label:"Java",children:(0,i.jsx)(o.default,{language:"java",children:n})}),a&&(0,i.jsx)(l.A,{value:"kotlin",label:"Kotlin",children:(0,i.jsx)(o.default,{language:"kotlin",children:a})}),r&&(0,i.jsx)(l.A,{value:"go",label:"Go",children:(0,i.jsx)(o.default,{language:"go",children:r})}),c&&(0,i.jsx)(l.A,{value:"csharp",label:"C#",children:(0,i.jsx)(o.default,{language:"csharp",children:c})}),u&&(0,i.jsx)(l.A,{value:"php",label:"PHP",children:(0,i.jsx)(o.default,{language:"php",children:u})}),d&&(0,i.jsx)(l.A,{value:"rust",label:"Rust",children:(0,i.jsx)(o.default,{language:"rust",children:d})}),h&&(0,i.jsx)(l.A,{value:"ruby",label:"Ruby",children:(0,i.jsx)(o.default,{language:"ruby",children:h})}),m&&(0,i.jsx)(l.A,{value:"elixir",label:"Elixir",children:(0,i.jsx)(o.default,{language:"elixir",children:m})}),p&&(0,i.jsx)(l.A,{value:"swift",label:"Swift",children:(0,i.jsx)(o.default,{language:"swift",children:p})}),f&&(0,i.jsx)(l.A,{value:"dart",label:"Dart",children:(0,i.jsx)(o.default,{language:"dart",children:f})}),g&&(0,i.jsx)(l.A,{value:"cli",label:"CLI",children:(0,i.jsx)(o.default,{language:"cli",children:g})})]}):null,u={sidebar_position:2,sidebar_label:"Build a Rate-Limiter",title:"Implement a distributed rate-limiter using Momento",description:"Learn how you can implement a distributed rate-limiter using a centralized backend source, Momento."},d="Building a distributed and centralized rate-limiter using Momento",h={},m=[{value:"What is rate-limiting?",id:"what-is-rate-limiting",level:2},{value:"What\u2019s the use of rate-limiters?",id:"whats-the-use-of-rate-limiters",level:2},{value:"Using Momento to build a distributed rate-limiter",id:"using-momento-to-build-a-distributed-rate-limiter",level:2},{value:"We want more!",id:"we-want-more",level:2}];function p(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"building-a-distributed-and-centralized-rate-limiter-using-momento",children:"Building a distributed and centralized rate-limiter using Momento"})}),"\n",(0,i.jsx)(t.h2,{id:"what-is-rate-limiting",children:"What is rate-limiting?"}),"\n",(0,i.jsx)(t.p,{children:"Rate limiting is a strategy for limiting network traffic. It puts a cap on how often someone can repeat an action within a certain timeframe. Rate-limiting exists literally everywhere; whether you are looking at your Twitter news feed or streaming a live video, there\u2019s a non-zero chance that you are interacting with a rate-limiter. It is watching you, making decisions about your traffic, and rightfully stopping you if you start making too much noise."}),"\n",(0,i.jsx)(t.h2,{id:"whats-the-use-of-rate-limiters",children:"What\u2019s the use of rate-limiters?"}),"\n",(0,i.jsx)(t.p,{children:"The need for rate-limiting stems from the fundamental requirement to maintain the health and quality of any service. Without it, resources could easily become overwhelmed, leading to service degradation or outright failure. This is particularly important in distributed systems, web services, and multi-tenant applications where client requests can vary dramatically in volume and frequency. Rate-limiting ensures a fair distribution of resources, prevents abuse, and can even be a crucial component in defending against certain types of cyber-attacks, such as Distributed Denial of Service (DDoS) attacks."}),"\n",(0,i.jsx)(t.p,{children:"Some common use-cases of rate-limiting includes:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"API Management: In a platform offering various APIs, rate-limiting is crucial to prevent a single user or service from monopolizing the bandwidth, ensuring that all users have equitable access to the resources."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"E-commerce Websites: During high-traffic events like Black Friday sales, rate-limiting can prevent the website from crashing by controlling the influx of user requests, thus providing a stable and fair shopping experience to all customers."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Online Gaming Servers: Rate-limiting can help in mitigating cheating by throttling the number of actions a player can perform in a given time, ensuring a level playing field and maintaining the game's integrity."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"using-momento-to-build-a-distributed-rate-limiter",children:"Using Momento to build a distributed rate-limiter"}),"\n",(0,i.jsxs)(t.p,{children:["Let\u2019s imagine you want to create a distributed rate-limiter that could effectively manage transactions-per-minute (TPM) for individual users.\nOur approach utilizes Momento's ",(0,i.jsx)(t.code,{children:"increment"})," and ",(0,i.jsx)(t.code,{children:"updateTTL"})," ",(0,i.jsx)(t.a,{href:"/cache/develop/api-reference",children:"APIs"}),". This method proves to be not only efficient but also highly accurate."]}),"\n",(0,i.jsx)(t.p,{children:"At the heart of our rate-limiter is a key mechanism that allows us to perform rate limiting based on user-per-minute granularity. The key is constructed using a combination of a user or entity and the current minute. This key plays a pivotal role in tracking and limiting the number of transactions a user can make in a given minute."}),"\n",(0,i.jsx)(t.p,{children:"The rate limiter increments the value of the unique key for each user when they make a request, setting a time-to-live (TTL) for the first request of the minute to 60 seconds. This is important as we want our keys to expire as they are not meaningful after they have served their purpose for a given minute."}),"\n",(0,i.jsx)(t.p,{children:"A flow of the rate-limiter looks like:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Increment the value of ",(0,i.jsx)(t.code,{children:"user_id-current_minute"}),". If the returned value is 1, that indicates that this was the first request for the user for that given minute. Note that Momento's ",(0,i.jsx)(t.code,{children:"increment"})," API is guaranteed to be atomic. If this return value is 1, we set the TTL of that key using ",(0,i.jsx)(t.code,{children:"updateTTL"})," API to be 60 seconds."]}),"\n",(0,i.jsx)(t.li,{children:"If the value is less than the configured TPM limit for the rate limiter, we allow the request, or else, throttle it."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Let's dive right into our implementation; pay attention to comments in this code where we explain the thought process."}),"\n",(0,i.jsx)(c,{js:"import {\n  CacheClient,\n  CacheIncrementResponse,\n  CacheUpdateTtlResponse,\n  Configurations,\n  CreateCacheResponse,\n  CredentialProvider,\n} from '@gomomento/sdk';\n\n// since our rate limiting buckets are per minute, we expire keys every minute\nexport const RATE_LIMITER_TTL_MILLIS = 60000;\n\nexport class MomentoRateLimiter {\n  _client: CacheClient;\n  _limit: number;\n  _cacheName: string;\n\n  constructor(client: CacheClient, limit: number, cacheName: string) {\n    this._client = client;\n    this._limit = limit;\n    this._cacheName = cacheName;\n  }\n\n  /**\n   * Generates a unique key for a user (baseKey) for the current minute. This key will server as the backend\n   * cache key where we will store the amount of calls that have been made by a user for a given minute.\n   * @param baseKey\n   */\n  generateMinuteKey(baseKey: string): string {\n    const currentDate = new Date();\n    const currentMinute = currentDate.getMinutes();\n    return `${baseKey}_${currentMinute}`;\n  }\n\n  public async isLimitExceeded(id: string): Promise<boolean> {\n    const currentMinuteKey = this.generateMinuteKey(id);\n    // we do not pass a TTL to this; we don't know if the key for this user was present or not\n    const resp = await this._client.increment(\n      this._cacheName,\n      currentMinuteKey\n    );\n\n    switch (resp.type) {\n      case CacheIncrementResponse.Success: {\n        if (resp.value() <= this._limit) {\n          // if returned value is 1, we know this was the first request in this minute for the given user. So\n          // we set the TTL for this minute's key to 60 seconds now.\n          if (resp.value() === 1) {\n            const updateTTLResp = await this._client.updateTtl(\n              this._cacheName,\n              currentMinuteKey,\n              RATE_LIMITER_TTL_MILLIS\n            );\n            switch (updateTTLResp.type) {\n              case CacheUpdateTtlResponse.Set:\n                break;\n              case CacheUpdateTtlResponse.Miss:\n              case CacheUpdateTtlResponse.Error: {\n                console.error(\n                  `Failed to update TTL; this minute's user requests might be overcounted, key: ${currentMinuteKey}`\n                );\n                break;\n              }\n            }\n          }\n          return false;\n        }\n        break;\n      }\n\n      case CacheIncrementResponse.Error:\n        throw new Error(resp.message());\n    }\n\n    return true;\n  }\n}\n\nasync function main() {\n  const cacheClient = await CacheClient.create({\n    configuration: Configurations.Laptop.v1(),\n    credentialProvider:\n      CredentialProvider.fromEnvironmentVariable('MOMENTO_API_KEY'),\n    defaultTtlSeconds: 60,\n  });\n\n  const tpmLimit = 1;\n  const cacheName = 'rate-limiter';\n\n  const createCacheResp = await cacheClient.createCache(cacheName);\n  switch (createCacheResp.type) {\n    case CreateCacheResponse.AlreadyExists:\n      console.log(`${cacheName} cache already exists`);\n      break;\n    case CreateCacheResponse.Success:\n      console.log(`${cacheName} cache created`);\n      break;\n    case CreateCacheResponse.Error:\n      throw new Error(createCacheResp.message());\n  }\n\n  const momentoRateLimier = new MomentoRateLimiter(\n    cacheClient,\n    tpmLimit,\n    cacheName\n  );\n\n  const limitExceeded = await momentoRateLimier.isLimitExceeded('user-id');\n  if (!limitExceeded) {\n    // do work for user\n    console.log('Successfully called work and request was allowed');\n  } else {\n    console.warn('Request was throttled');\n  }\n}\n\nmain()\n  .then()\n  .catch((err: Error) => console.error(err.message));\n"}),"\n",(0,i.jsx)(t.h2,{id:"we-want-more",children:"We want more!"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["You can quickly get started with our SDK examples to play around the Momento rate limiter, where you can also simulate contention and cause your rate-limiter to throttle requests.","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://github.com/momentohq/client-sdk-javascript/tree/main/examples/nodejs/rate-limiter",children:"Typescript"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://www.gomomento.com/blog/did-you-say-you-want-a-distributed-rate-limiter",children:"Read our blog"})," where we analyze different heuristics of the rate-limiter and also compare it with other approaches."]}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},11470:(e,t,n)=>{n.d(t,{A:()=>k});var a=n(96540),i=n(34164),r=n(17559),s=n(23104),l=n(56347),o=n(205),c=n(57485),u=n(31682),d=n(70679);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return h(e).map((({props:{value:e,label:t,attributes:n,default:a}})=>({value:e,label:t,attributes:n,default:a})))}(n);return function(e){const t=(0,u.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p({value:e,tabValues:t}){return t.some((t=>t.value===e))}function f({queryString:e=!1,groupId:t}){const n=(0,l.W6)(),i=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,c.aZ)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,r=m(e),[s,l]=(0,a.useState)((()=>function({defaultValue:e,tabValues:t}){if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[c,u]=f({queryString:n,groupId:i}),[h,g]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[n,i]=(0,d.Dv)(t);return[n,(0,a.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:i}),b=(()=>{const e=c??h;return p({value:e,tabValues:r})?e:null})();(0,o.A)((()=>{b&&l(b)}),[b]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,r]),tabValues:r}}var b=n(92303);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var w=n(74848);function y({className:e,block:t,selectedValue:n,selectValue:a,tabValues:r}){const l=[],{blockElementScrollPositionUntilNextRender:o}=(0,s.a_)(),c=e=>{const t=e.currentTarget,i=l.indexOf(t),s=r[i].value;s!==n&&(o(t),a(s))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":t},e),children:r.map((({value:e,label:t,attributes:a})=>(0,w.jsx)("li",{role:"tab",tabIndex:n===e?0:-1,"aria-selected":n===e,ref:e=>{l.push(e)},onKeyDown:u,onClick:c,...a,className:(0,i.A)("tabs__item",v.tabItem,a?.className,{"tabs__item--active":n===e}),children:t??e},e)))})}function x({lazy:e,children:t,selectedValue:n}){const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=r.find((e=>e.props.value===n));return e?(0,a.cloneElement)(e,{className:(0,i.A)("margin-top--md",e.props.className)}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n})))})}function j(e){const t=g(e);return(0,w.jsxs)("div",{className:(0,i.A)(r.G.tabs.container,"tabs-container",v.tabList),children:[(0,w.jsx)(y,{...t,...e}),(0,w.jsx)(x,{...t,...e})]})}function k(e){const t=(0,b.A)();return(0,w.jsx)(j,{...e,children:h(e.children)},String(t))}},19365:(e,t,n)=>{n.d(t,{A:()=>s});n(96540);var a=n(34164);const i={tabItem:"tabItem_Ymn6"};var r=n(74848);function s({children:e,hidden:t,className:n}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)(i.tabItem,n),hidden:t,children:e})}},42821:(e,t,n)=>{n(96540)},70503:(e,t,n)=>{n.d(t,{F:()=>r});var a=n(83457),i=(n(96540),n(74848));const r=({language:e,code:t})=>(0,i.jsx)(a.default,{language:e,children:t})}}]);