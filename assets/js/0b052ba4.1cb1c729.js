"use strict";(globalThis.webpackChunkmomento_docs=globalThis.webpackChunkmomento_docs||[]).push([[5035],{35347:(e,t,n)=>{n.d(t,{r:()=>g});var s=n(11470),r=n(19365),c=n(83457),i=(n(96540),n(27293)),a=n(74848);const h="https://github.com/momentohq/client-sdk-javascript/blob/main/examples/nodejs/cache/doc-example-files/doc-examples-js-apis.ts",l="https://github.com/momentohq/client-sdk-python/blob/main/examples/py310/doc-examples-python-apis.py",o="https://github.com/momentohq/client-sdk-java/blob/main/examples/cache/src/main/java/momento/client/example/doc_examples/DocExamplesJavaAPIs.java",d="https://github.com/momentohq/client-sdk-kotlin/blob/main/examples/src/main/kotlin/software/momento/example/doc_examples/DocExamples.kt",u="https://github.com/momentohq/client-sdk-go/blob/main/examples/docs-examples/main.go",p="https://github.com/momentohq/client-sdk-dotnet/blob/main/examples/DocExampleApis/Program.cs",x="https://github.com/momentohq/client-sdk-php/blob/main/examples/doc-examples-php-apis.php",j="https://github.com/momentohq/client-sdk-rust/blob/main/example/rust/src/docs_examples/docs_examples.rs",m="https://github.com/momentohq/client-sdk-elixir/blob/main/examples/doc_examples.exs",y="https://github.com/momentohq/client-sdk-swift/blob/main/Examples/doc-example-apis/Sources/main.swift",f="https://github.com/momentohq/client-sdk-dart/blob/main/example/doc_example_apis/bin/doc_example_apis.dart",g=({js:e,python:t,java:n,kotlin:g,go:S,csharp:k,php:v,rust:w,ruby:C,elixir:b,swift:N,dart:E,cli:A})=>e||t||n||g||S||k||v||w||C||b||N||E||A?(0,a.jsxs)(s.A,{children:[e&&(0,a.jsxs)(r.A,{value:"js",label:"JavaScript",children:[(0,a.jsx)(c.default,{language:"js",children:e}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:h,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),t&&(0,a.jsxs)(r.A,{value:"python",label:"Python",children:[(0,a.jsx)(c.default,{language:"python",children:t}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:l,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),n&&(0,a.jsxs)(r.A,{value:"java",label:"Java",children:[(0,a.jsx)(c.default,{language:"java",children:n}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:o,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),g&&(0,a.jsxs)(r.A,{value:"kotlin",label:"Kotlin",children:[(0,a.jsx)(c.default,{language:"kotlin",children:g}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:d,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),S&&(0,a.jsxs)(r.A,{value:"go",label:"Go",children:[(0,a.jsx)(c.default,{language:"go",children:S}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:u,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),k&&(0,a.jsxs)(r.A,{value:"csharp",label:"C#",children:[(0,a.jsx)(c.default,{language:"csharp",children:k}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:p,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),v&&(0,a.jsxs)(r.A,{value:"php",label:"PHP",children:[(0,a.jsx)(c.default,{language:"php",children:v}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:x,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),w&&(0,a.jsxs)(r.A,{value:"rust",label:"Rust",children:[(0,a.jsx)(c.default,{language:"rust",children:w}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:j,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),C&&(0,a.jsx)(r.A,{value:"ruby",label:"Ruby",children:(0,a.jsx)(c.default,{language:"ruby",children:C})}),b&&(0,a.jsxs)(r.A,{value:"elixir",label:"Elixir",children:[(0,a.jsx)(c.default,{language:"elixir",children:b}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:m,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),N&&(0,a.jsxs)(r.A,{value:"swift",label:"Swift",children:[(0,a.jsx)(c.default,{language:"swift",children:N}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:y,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),E&&(0,a.jsxs)(r.A,{value:"dart",label:"Dart",children:[(0,a.jsx)(c.default,{language:"dart",children:E}),(0,a.jsxs)(i.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:f,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),A&&(0,a.jsx)(r.A,{value:"cli",label:"CLI",children:(0,a.jsx)(c.default,{language:"cli",children:A})})]}):null},51441:(e,t,n)=>{n(96540)},74840:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>h,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"cache/develop/api-reference/index","title":"API reference information","description":"Learn the API calls you need to know and how to use them with Momento.","source":"@site/docs/cache/develop/api-reference/index.mdx","sourceDirName":"cache/develop/api-reference","slug":"/cache/develop/api-reference/","permalink":"/cache/develop/api-reference/","draft":false,"unlisted":false,"editUrl":"https://github.com/momentohq/public-dev-docs/tree/main/docs/cache/develop/api-reference/index.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"API reference information","pagination_prev":null,"sidebar_label":"API Reference","description":"Learn the API calls you need to know and how to use them with Momento."},"sidebar":"cacheSidebar","next":{"title":"Dictionary","permalink":"/cache/develop/api-reference/dictionary-collections"}}');var r=n(74848),c=n(28453),i=(n(51441),n(35347));const a={sidebar_position:1,title:"API reference information",pagination_prev:null,sidebar_label:"API Reference",description:"Learn the API calls you need to know and how to use them with Momento."},h="API reference for Momento Cache",l={},o=[{value:"Control APIs",id:"control-apis",level:2},{value:"Create cache",id:"create-cache",level:3},{value:"Delete cache",id:"delete-cache",level:3},{value:"List caches",id:"list-caches",level:3},{value:"Flush cache",id:"flush-cache",level:3},{value:"Data APIs",id:"data-apis",level:2},{value:"Set",id:"set",level:3},{value:"SetBatch",id:"setbatch",level:3},{value:"Get",id:"get",level:3},{value:"GetBatch",id:"getbatch",level:3},{value:"Delete",id:"delete",level:3},{value:"Increment",id:"increment",level:3},{value:"Ping",id:"ping",level:3},{value:"ItemGetType",id:"itemgettype",level:3},{value:"KeyExists",id:"keyexists",level:3},{value:"KeysExist",id:"keysexist",level:3},{value:"SetIfAbsent",id:"setifabsent",level:3},{value:"SetIfPresent",id:"setifpresent",level:3},{value:"SetIfEqual",id:"setifequal",level:3},{value:"SetIfNotEqual",id:"setifnotequal",level:3},{value:"SetIfPresentAndNotEqual",id:"setifpresentandnotequal",level:3},{value:"SetIfAbsentOrEqual",id:"setifabsentorequal",level:3},{value:"GetWithHash",id:"getwithhash",level:3},{value:"SetWithHash",id:"setwithhash",level:3},{value:"SetIfPresentAndHashEqual",id:"setifpresentandhashequal",level:3},{value:"SetIfPresentAndHashNotEqual",id:"setifpresentandhashnotequal",level:3},{value:"SetIfAbsentOrHashEqual",id:"setifabsentorhashequal",level:3},{value:"SetIfAbsentOrHashNotEqual",id:"setifabsentorhashnotequal",level:3},{value:"Time to Live APIs",id:"time-to-live-apis",level:2},{value:"UpdateTtl",id:"updatettl",level:3},{value:"IncreaseTtl",id:"increasettl",level:3},{value:"DecreaseTtl",id:"decreasettl",level:3},{value:"ItemGetTtl",id:"itemgetttl",level:3},{value:"Collection data types",id:"collection-data-types",level:2},{value:"Current status of API support in SDKs",id:"current-status-of-api-support-in-sdks",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"api-reference-for-momento-cache",children:"API reference for Momento Cache"})}),"\n",(0,r.jsx)(t.h2,{id:"control-apis",children:"Control APIs"}),"\n",(0,r.jsx)(t.p,{children:"These API methods are used to manage and control caches."}),"\n",(0,r.jsx)(t.h3,{id:"create-cache",children:"Create cache"}),"\n",(0,r.jsx)(t.p,{children:"Creates a cache with the provided name"}),"\n",(0,r.jsx)(t.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache to be created."})]})})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.createCache(cacheName);\nswitch (result.type) {\n  case CreateCacheResponse.AlreadyExists:\n    console.log(`Cache '${cacheName}' already exists`);\n    break;\n  case CreateCacheResponse.Success:\n    console.log(`Cache '${cacheName}' created`);\n    break;\n  case CreateCacheResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to create cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:'create_cache_response = await cache_client.create_cache("test-cache")\nmatch create_cache_response:\n    case CreateCache.Success():\n        print("Cache \'test-cache\' created")\n    case CreateCache.CacheAlreadyExists():\n        print("Cache \'test-cache\' already exists.")\n    case CreateCache.Error() as error:\n        print(f"An error occurred while attempting to create cache \'test-cache\': {error.message}")\n\n',java:'final CacheCreateResponse response = cacheClient.createCache("test-cache").join();\nif (response instanceof CacheCreateResponse.Success) {\n  System.out.println("Cache \'test-cache\' created");\n} else if (response instanceof CacheCreateResponse.Error error) {\n  if (error.getErrorCode() == MomentoErrorCode.ALREADY_EXISTS_ERROR) {\n    System.out.println("Cache \'test-cache\' already exists");\n  } else {\n    throw new RuntimeException(\n        "An error occurred while attempting to create cache \'test-cache\': "\n            + error.getErrorCode(),\n        error);\n  }\n}',kotlin:'when (val response = cacheClient.createCache("test-cache")) {\n    is CacheCreateResponse.Success -> println("Cache \'test-cache\' created")\n    is CacheCreateResponse.AlreadyExists -> println("Cache \'test-cache\' already exists")\n    is CacheCreateResponse.Error -> throw RuntimeException(\n        "An error occurred while attempting to create cache \'test-cache\': ${response.errorCode}", response\n    )\n}',go:"_, err := client.CreateCache(ctx, &momento.CreateCacheRequest{\n\tCacheName: cacheName,\n})\nif err != nil {\n\tpanic(err)\n}",csharp:'var result = await cacheClient.CreateCacheAsync("test-cache");\nif (result is CreateCacheResponse.Success)\n{\n    Console.WriteLine("Cache \'test-cache\' created");\n}\nelse if (result is CreateCacheResponse.CacheAlreadyExists)\n{\n    Console.WriteLine("Cache \'test-cache\' already exists");\n}\nelse if (result is CreateCacheResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to create cache \'test-cache\': {error.ErrorCode}: {error}");\n}',php:'\n$create_cache_response = $cache_client->createCache($cache_name);\nif ($create_cache_response->asSuccess()) {\n    print("Cache $cache_name created\\n");\n} elseif ($create_cache_response->asAlreadyExists()) {\n    print("Cache $cache_name already exists\\n");\n} elseif ($err = $create_cache_response->asError()) {\n    print("An error occurred while attempting to create $cache_name: {$err->errorCode()} - {$err->message()}\\n");\n}',rust:'  match cache_client.create_cache(cache_name).await? {\n      CreateCacheResponse::Created => println!("Cache {cache_name} created"),\n      CreateCacheResponse::AlreadyExists => println!("Cache {cache_name} already exists"),\n  }',elixir:'case Momento.CacheClient.create_cache(client, "test-cache") do\n  {:ok, _} ->\n    IO.puts("Cache \'test-cache\' created")\n\n  :already_exists ->\n    :ok\n\n  {:error, error} ->\n    IO.puts(\n      "An error occurred while attempting to create cache \'test-cache\': #{error.error_code}"\n    )\n\n    raise error\nend',swift:'let result = await cacheClient.createCache(cacheName: cacheName)\nswitch result {\ncase .alreadyExists(_):\n    print("Cache already exists!")\ncase .success(_):\n    print("Successfully created the cache!")\ncase .error(let err):\n    print("Unable to create the cache: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.createCache("test-cache");\nswitch (result) {\n  case CreateCacheAlreadyExists():\n    print("Cache already exists");\n  case CreateCacheError():\n    print("Error creating cache: $result");\n  case CreateCacheSuccess():\n    print("Successfully created the cache");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"delete-cache",children:"Delete cache"}),"\n",(0,r.jsx)(t.p,{children:"Deletes a cache"}),"\n",(0,r.jsx)(t.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache to be deleted."})]})})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.deleteCache(cacheName);\nswitch (result.type) {\n  case DeleteCacheResponse.Success:\n    console.log(`Cache '${cacheName}' deleted`);\n    break;\n  case DeleteCacheResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to delete cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:'delete_cache_response = await cache_client.delete_cache("test-cache")\nmatch delete_cache_response:\n    case DeleteCache.Success():\n        print("Cache \'test-cache\' deleted")\n    case DeleteCache.Error() as error:\n        raise Exception(f"An error occurred while attempting to delete \'test-cache\': {error.message}")\n\n',java:'final CacheDeleteResponse response = cacheClient.deleteCache("test-cache").join();\nif (response instanceof CacheDeleteResponse.Success) {\n  System.out.println("Cache \'test-cache\' deleted");\n} else if (response instanceof CacheDeleteResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to delete cache \'test-cache\': "\n          + error.getErrorCode(),\n      error);\n}',kotlin:'when (val response = cacheClient.deleteCache("test-cache")) {\n    is CacheDeleteResponse.Success -> println("Cache \'test-cache\' deleted")\n    is CacheDeleteResponse.Error -> throw RuntimeException(\n        "An error occurred while attempting to delete cache \'test-cache\': ${response.errorCode}", response\n    )\n}',go:"_, err := client.DeleteCache(ctx, &momento.DeleteCacheRequest{\n\tCacheName: cacheName,\n})\nif err != nil {\n\tpanic(err)\n}",csharp:'var result = await cacheClient.DeleteCacheAsync("test-cache");\nif (result is DeleteCacheResponse.Success)\n{\n    Console.WriteLine("Cache \'test-cache\' deleted");\n}\nelse if (result is DeleteCacheResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to delete cache \'test-cache\': {error.ErrorCode}: {error}");\n}',php:'\n$delete_cache_response = $cache_client->deleteCache($cache_name);\nif ($err = $delete_cache_response->asError()) {\n    print("An error occurred while attempting to delete $cache_name: {$err->errorCode()} - {$err->message()}\\n");\n} else {\n    print("Cache $cache_name deleted\\n");\n}',rust:'  cache_client.delete_cache(cache_name).await?;\n  println!("Cache {cache_name} deleted");',elixir:'case Momento.CacheClient.delete_cache(client, "test-cache") do\n  {:ok, _} ->\n    IO.puts("Cache \'test-cache\' deleted")\n\n  {:error, error} ->\n    IO.puts(\n      "An error occurred while attempting to delete cache \'test-cache\': #{error.error_code}"\n    )\n\n    raise error\nend',swift:'let result = await cacheClient.deleteCache(cacheName: cacheName)\nswitch result {\ncase .success(let success):\n    print("Successfully deleted the cache")\ncase .error(let err):\n    print("Unable to delete cache: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.deleteCache("test-cache");\nswitch (result) {\n  case DeleteCacheError():\n    print("Error deleting cache: $result");\n    exit(1);\n  case DeleteCacheSuccess():\n    print("Successfully deleted cache");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"list-caches",children:"List caches"}),"\n",(0,r.jsx)(t.p,{children:"Lists all caches"}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.listCaches();\nswitch (result.type) {\n  case ListCachesResponse.Success:\n    console.log(\n      `Caches:\\n${result\n        .getCaches()\n        .map(c => c.getName())\n        .join('\\n')}\\n\\n`\n    );\n    break;\n  case ListCachesResponse.Error:\n    throw new Error(`An error occurred while attempting to list caches: ${result.errorCode()}: ${result.toString()}`);\n}",python:'print("Listing caches:")\nlist_caches_response = await cache_client.list_caches()\nmatch list_caches_response:\n    case ListCaches.Success() as success:\n        for cache_info in success.caches:\n            print(f"- {cache_info.name!r}")\n    case ListCaches.Error() as error:\n        raise Exception(f"An error occurred while attempting to list caches: {error.message}")\n\n',java:'final CacheListResponse response = cacheClient.listCaches().join();\nif (response instanceof CacheListResponse.Success success) {\n  final String caches =\n      success.getCaches().stream().map(CacheInfo::name).collect(Collectors.joining("\\n"));\n  System.out.println("Caches:\\n" + caches);\n} else if (response instanceof CacheListResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to list caches: " + error.getErrorCode(), error);\n}',kotlin:'when (val response: CacheListResponse = cacheClient.listCaches()) {\n    is CacheListResponse.Success -> {\n        val caches: String = response.caches.joinToString("\\n") { cacheInfo -> cacheInfo.name }\n        println("Caches:\\n$caches")\n    }\n\n    is CacheListResponse.Error -> throw RuntimeException(\n        "An error occurred while attempting to list caches: ${response.errorCode}", response\n    )\n}',go:'resp, err := client.ListCaches(ctx, &momento.ListCachesRequest{})\nif err != nil {\n\tpanic(err)\n}\n\nswitch r := resp.(type) {\ncase *responses.ListCachesSuccess:\n\tlog.Printf("Found caches %+v\\n", r.Caches())\n}',csharp:'var result = await cacheClient.ListCachesAsync();\nif (result is ListCachesResponse.Success success)\n{\n    Console.WriteLine($"Caches:\\n{string.Join("\\n", success.Caches.Select(c => c.Name))}\\n\\n");\n}\nelse if (result is ListCachesResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to list caches: {error.ErrorCode}: {error}");\n}',php:'\n$list_caches_response = $cache_client->listCaches();\nif ($success = $list_caches_response->asSuccess()) {\n    print("Found caches:\\n");\n    foreach ($success->caches() as $cache) {\n        $cache_name = $cache->name();\n        print("- $cache_name\\n");\n    }\n} elseif ($err = $list_caches_response->asError()) {\n    print("An error occurred while attempting to list caches: {$err->errorCode()} - {$err->message()}\\n");\n}',rust:'  let response = cache_client.list_caches().await?;\n  println!("Caches: {:#?}", response.caches);',elixir:'case Momento.CacheClient.list_caches(client) do\n  {:ok, result} ->\n    IO.puts("Caches:")\n    IO.inspect(result.caches)\n\n  {:error, error} ->\n    IO.puts("An error occurred while attempting to list caches: #{error.error_code}")\n    raise error\nend',swift:'let result = await cacheClient.listCaches()\nswitch result {\ncase .success(let success):\n    print("Successfully fetched list of caches: \\(success.caches.map { $0.name })")\ncase .error(let err):\n    print("Unable to fetch list of caches: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.listCaches();\nswitch (result) {\n  case ListCachesError():\n    print("Error listing caches: $result");\n  case ListCachesSuccess():\n    print("Successfully listed caches: ${result.cacheNames}");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"flush-cache",children:"Flush cache"}),"\n",(0,r.jsx)(t.p,{children:"Flushes all data from a cache"}),"\n",(0,r.jsx)(t.p,{children:"Attributes:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache to be flushed."})]})})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.flushCache(cacheName);\nswitch (result.type) {\n  case FlushCacheResponse.Success:\n    console.log(`Cache '${cacheName}' flushed`);\n    break;\n  case FlushCacheResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to flush cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:'final CacheFlushResponse response = cacheClient.flushCache("test-cache").join();\nif (response instanceof CacheFlushResponse.Success) {\n  System.out.println("Cache \'test-cache\' flushed");\n} else if (response instanceof CacheFlushResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to flush cache \'test-cache\': " + error.getErrorCode(),\n      error);\n}',kotlin:"",go:"",csharp:'var result = await cacheClient.FlushCacheAsync("test-cache");\nif (result is FlushCacheResponse.Success)\n{\n    Console.WriteLine("Cache \'test-cache\' flushed");\n}\nelse if (result is FlushCacheResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to flush cache \'test-cache\': {error.ErrorCode}: {error}");\n}',php:"",rust:'  cache_client.flush_cache(cache_name.to_string()).await?;\n  println!("Cache {cache_name} flushed");',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["While you could use ",(0,r.jsx)(t.a,{href:"#delete-cache",children:"Delete Cache"}),", then ",(0,r.jsx)(t.a,{href:"#create-cache",children:"Create Cache"})," to mimic this, the FlushCache API keeps the settings and only deletes the data in the cache."]})}),"\n",(0,r.jsx)(t.h2,{id:"data-apis",children:"Data APIs"}),"\n",(0,r.jsx)(t.p,{children:"These API methods are used to directly interact with data in a cache."}),"\n",(0,r.jsx)(t.h3,{id:"set",children:"Set"}),"\n",(0,r.jsx)(t.p,{children:"Sets the value in cache with a given Time To Live (TTL) seconds. If a value for this key is already present, it will be replaced by the new value regardless of the previous value's data type."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"[]Byte"}),(0,r.jsx)(t.td,{children:"The key under which the value is to be added."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"[]Byte"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"int"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.set(cacheName, 'test-key', 'test-value');\nswitch (result.type) {\n  case CacheSetResponse.Success:\n    console.log(\"Key 'test-key' stored successfully\");\n    break;\n  case CacheSetResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to store key 'test-key' in cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:'set_response = await cache_client.set("test-cache", "test-key", "test-value")\nmatch set_response:\n    case CacheSet.Success():\n        print("Key \'test-key\' stored successfully")\n    case CacheSet.Error() as error:\n        raise Exception(\n            f"An error occurred while attempting to store key \'test-key\' in cache \'test-cache\': {error.message}"\n        )\n\n',java:'final SetResponse response = cacheClient.set("test-cache", "test-key", "test-value").join();\nif (response instanceof SetResponse.Success) {\n  System.out.println("Key \'test-key\' stored successfully");\n} else if (response instanceof SetResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to store key \'test-key\' in cache \'test-cache\': "\n          + error.getErrorCode(),\n      error);\n}',kotlin:'when (val response = cacheClient.set("test-cache", "test-key", "test-value")) {\n    is SetResponse.Success -> println("Key \'test-key\' stored successfully")\n    is SetResponse.Error -> throw RuntimeException(\n        "An error occurred while attempting to store key \'test-key\' in cache \'test-cache\': ${response.errorCode}",\n        response\n    )\n}',go:'key := uuid.NewString()\nvalue := uuid.NewString()\nlog.Printf("Setting key: %s, value: %s\\n", key, value)\n_, err := client.Set(ctx, &momento.SetRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String(key),\n\tValue:     momento.String(value),\n\tTtl:       time.Duration(9999),\n})\nif err != nil {\n\tvar momentoErr momento.MomentoError\n\tif errors.As(err, &momentoErr) {\n\t\tif momentoErr.Code() != momento.TimeoutError {\n\t\t\t// this would represent a client-side timeout, and you could fall back to your original data source\n\t\t} else {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}',csharp:'var result = await cacheClient.SetAsync("test-cache", "test-key", "test-value");\nif (result is CacheSetResponse.Success)\n{\n    Console.WriteLine("Key \'test-key\' stored successfully");\n}\nelse if (result is CacheSetResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to store key \'test-key\' in cache \'test-cache\': {error.ErrorCode}: {error}");\n}',php:'\n$set_response = $cache_client->set($cache_name, "test-key", "test-value");\nif ($set_response->asSuccess()) {\n    print("Key $cache_name stored successfully\\n");\n} elseif ($err = $set_response->asError()) {\n    print("An error occurred while attempting to store $cache_name: {$err->errorCode()} - {$err->message()}\\n");\n}',rust:'  cache_client.set(cache_name, "key", "value").await?;\n  println!("Value stored");',elixir:'case Momento.CacheClient.set(client, "test-cache", "test-key", "test-value") do\n  {:ok, _} ->\n    IO.puts("Key \'test-key\' stored successfully")\n\n  {:error, error} ->\n    IO.puts(\n      "An error occurred while attempting to store key \'test-key\' in cache \'test-cache\': #{error.error_code}"\n    )\n\n    raise error\nend',swift:'let result = await cacheClient.set(\n    cacheName: cacheName,\n    key: "key",\n    value: "value"\n)\nswitch result {\ncase .success(_):\n    print("Successfully set item in the cache")\ncase .error(let err):\n    print("Unable to set item in the cache: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.set("test-cache", "test-key", "test-value");\nswitch (result) {\n  case SetError():\n    print("Error setting key: $result");\n    exit(1);\n  case SetSuccess():\n    print("Successfully set item in the cache");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setbatch",children:"SetBatch"}),"\n",(0,r.jsx)(t.p,{children:"Sets multiple key-value pairs in a cache with a given Time To Live (TTL) seconds. If a value for a key is already present, it will be replaced by the new value regardless of the previous value's data type."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"items"}),(0,r.jsx)(t.td,{children:"{ String/[]Byte :  String/[]Byte }"}),(0,r.jsx)(t.td,{children:"The mapping of keys to values that should be stored"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"int"}),(0,r.jsx)(t.td,{children:"Time to Live for the items in Cache."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"const values = new Map<string, string>([\n  ['abc', '123'],\n  ['xyz', '321'],\n  ['123', 'xyz'],\n  ['321', 'abc'],\n]);\nconst result = await cacheClient.setBatch(cacheName, values);\nswitch (result.type) {\n  case CacheSetBatchResponse.Success:\n    console.log('Keys and values stored successfully');\n    break;\n  case CacheSetBatchResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to batch set in cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetBatch(ctx, &momento.SetBatchRequest{\n\tCacheName: cacheName,\n\tItems: []momento.BatchSetItem{\n\t\t{\n\t\t\tKey:   momento.String("key1"),\n\t\t\tValue: momento.String("value1"),\n\t\t},\n\t\t{\n\t\t\tKey:   momento.String("key2"),\n\t\t\tValue: momento.String("value2"),\n\t\t},\n\t},\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetBatchSuccess:\n\tlog.Printf("Successfully set keys in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Success"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"results()"}),": CacheSet.Response[]"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]})]}),"\n",(0,r.jsx)(t.h3,{id:"get",children:"Get"}),"\n",(0,r.jsx)(t.p,{children:"Get the cache value stored for the given key."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"[]Byte"}),(0,r.jsx)(t.td,{children:"The key under which the value is to be retrieved."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"const getResponse = await cacheClient.get(cacheName, 'test-key');\n// simplified style; assume the value was found\nconsole.log(`cache hit: ${getResponse.value()!}`);\n\n// pattern-matching style; safer for production code\nswitch (getResponse.type) {\n  case CacheGetResponse.Hit:\n    console.log(`Retrieved value for key 'test-key': ${getResponse.valueString()}`);\n    break;\n  case CacheGetResponse.Miss:\n    console.log(`Key 'test-key' was not found in cache '${cacheName}'`);\n    break;\n  case CacheGetResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to get key 'test-key' from cache '${cacheName}': ${getResponse.errorCode()}: ${getResponse.toString()}`\n    );\n}",python:"get_response = await cache_client.get(\"test-cache\", \"test-key\")\nmatch get_response:\n    case CacheGet.Hit() as hit:\n        print(f\"Retrieved value for key 'test-key': {hit.value_string}\")\n    case CacheGet.Miss():\n        print(\"Key 'test-key' was not found in cache 'test-cache'\")\n    case CacheGet.Error() as error:\n        raise Exception(\n            f\"An error occurred while attempting to get key 'test-key' from cache 'test-cache': {error.message}\"\n        )\n\n",java:"final GetResponse response = cacheClient.get(\"test-cache\", \"test-key\").join();\nif (response instanceof GetResponse.Hit hit) {\n  System.out.println(\"Retrieved value for key 'test-key': \" + hit.valueString());\n} else if (response instanceof GetResponse.Miss) {\n  System.out.println(\"Key 'test-key' was not found in cache 'test-cache'\");\n} else if (response instanceof GetResponse.Error error) {\n  throw new RuntimeException(\n      \"An error occurred while attempting to get key 'test-key' from cache 'test-cache': \"\n          + error.getErrorCode(),\n      error);\n}",kotlin:"when (val response = cacheClient.get(\"test-cache\", \"test-key\")) {\n    is GetResponse.Hit -> println(\"Retrieved value for key 'test-key': ${response.value}\")\n    is GetResponse.Miss -> println(\"Key 'test-key' was not found in cache 'test-cache'\")\n    is GetResponse.Error -> throw RuntimeException(\n        \"An error occurred while attempting to get key 'test-key' from cache 'test-cache': ${response.errorCode}\",\n        response\n    )\n}",go:'key := uuid.NewString()\nresp, err := client.Get(ctx, &momento.GetRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String(key),\n})\nif err != nil {\n\tpanic(err)\n}\n\nswitch r := resp.(type) {\ncase *responses.GetHit:\n\tlog.Printf("Lookup resulted in cache HIT. value=%s\\n", r.ValueString())\ncase *responses.GetMiss:\n\tlog.Printf("Look up did not find a value key=%s\\n", key)\n}',csharp:"var result = await cacheClient.GetAsync(\"test-cache\", \"test-key\");\nif (result is CacheGetResponse.Hit hit)\n{\n    Console.WriteLine($\"Retrieved value for key 'test-key': {hit.ValueString}\");\n}\nelse if (result is CacheGetResponse.Miss)\n{\n    Console.WriteLine(\"Key 'test-key' was not found in cache 'test-cache'\");\n}\nelse if (result is CacheGetResponse.Error error)\n{\n    throw new Exception($\"An error occurred while attempting to get key 'test-key' from cache 'test-cache': {error.ErrorCode}: {error}\");\n}",php:'\n$get_response = $cache_client->get($cache_name, "test-key");\nif ($hit = $get_response->asHit()) {\n    print("Retrieved value for key \'test-key\': {$hit->valueString()}\\n");\n} elseif ($get_response->asMiss()) {\n    print("Key \'test-key\' was not found in cache $cache_name\\n");\n} elseif ($err = $get_response->asError()) {\n    print("An error occurred while attempting to get key \'test-key\' from cache $cache_name: {$err->errorCode()} - {$err->message()}\\n");\n}',rust:'  let response = cache_client.get(cache_name, "key").await?;\n  let item: String = response.try_into().expect("I stored a string!");',elixir:"case Momento.CacheClient.get(client, \"test-cache\", \"test-key\") do\n  {:ok, hit} ->\n    IO.puts(\"Retrieved value for key 'test-key': #{hit.value}\")\n\n  :miss ->\n    IO.puts(\"Key 'test-key' was not found in cache 'test-cache'\")\n\n  {:error, error} ->\n    IO.puts(\n      \"An error occurred while attempting to get key 'test-key' from cache 'test-cache': #{error.error_code}\"\n    )\n\n    raise error\nend",swift:'let result = await cacheClient.get(\n    cacheName: cacheName,\n    key: "key"\n)\nswitch result {\ncase .hit(let hit):\n    print("Cache hit: \\(hit.valueString)")\ncase .miss(_):\n    print("Cache miss")\ncase .error(let err):\n    print("Unable to get item in the cache: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.get("test-cache", "test-key");\nswitch (result) {\n  case GetMiss():\n    print("Key was not found in cache.");\n  case GetError():\n    print("Error getting key: $result");\n  case GetHit():\n    print("Successfully got item from cache: ${result.value}");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"getbatch",children:"GetBatch"}),"\n",(0,r.jsx)(t.p,{children:"Get the cache values stored for the given keys."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"keys"}),(0,r.jsx)(t.td,{children:"String[] / Bytes[]"}),(0,r.jsx)(t.td,{children:"The list of keys for which to retrieve values."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"const keys = ['abc', 'xyz', '123', '321'];\nconst getBatchResponse = await cacheClient.getBatch(cacheName, keys);\n\n// simplified style; assume the value was found\nconst values = getBatchResponse.values()!;\nfor (const key of keys) {\n  console.log(`Retrieved value for key '${key}': ${values[key]}`);\n}\n\n// pattern-matching style; safer for production code\nswitch (getBatchResponse.type) {\n  case CacheGetBatchResponse.Success: {\n    const values = getBatchResponse.values();\n    for (const key of keys) {\n      console.log(`Retrieved value for key '${key}': ${values[key]}`);\n    }\n    break;\n  }\n  case CacheGetBatchResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to batch get in cache '${cacheName}': ${getBatchResponse.errorCode()}: ${getBatchResponse.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.GetBatch(ctx, &momento.GetBatchRequest{\n\tCacheName: cacheName,\n\tKeys:      []momento.Value{momento.String("key1"), momento.String("key2")},\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.GetBatchSuccess:\n\tlog.Printf("Found values %+v\\n", r.ValueMap())\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Success"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"values()"}),": Record<string, string>"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"results()"}),": CacheGet.Response[]"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]})]}),"\n",(0,r.jsx)(t.h3,{id:"delete",children:"Delete"}),"\n",(0,r.jsx)(t.p,{children:"Delete the cache value stored for the given key."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"[]Byte"}),(0,r.jsx)(t.td,{children:"The key under which the value is to be deleted."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.delete(cacheName, 'test-key');\nswitch (result.type) {\n  case CacheDeleteResponse.Success:\n    console.log(\"Key 'test-key' deleted successfully\");\n    break;\n  case CacheDeleteResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to delete key 'test-key' from cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:'delete_response = await cache_client.delete("test-cache", "test-key")\nmatch delete_response:\n    case CacheDelete.Success():\n        print("Key \'test-key\' deleted successfully")\n    case CacheDelete.Error() as error:\n        raise Exception(\n            f"An error occurred while attempting to delete key \'test-key\' from cache \'test-cache\': {error.message}"\n        )\n\n',java:'final DeleteResponse response = cacheClient.delete("test-cache", "test-key").join();\nif (response instanceof DeleteResponse.Success) {\n  System.out.println("Key \'test-key\' deleted successfully");\n} else if (response instanceof DeleteResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to delete key \'test-key\' from cache \'test-cache\': "\n          + error.getErrorCode(),\n      error);\n}',kotlin:'when (val response = cacheClient.delete("test-cache", "test-key")) {\n    is DeleteResponse.Success -> println("Key \'test-key\' deleted successfully")\n    is DeleteResponse.Error -> throw RuntimeException(\n        "An error occurred while attempting to delete key \'test-key\' from cache \'test-cache\': ${response.errorCode}",\n        response\n    )\n}',go:"key := uuid.NewString()\n_, err := client.Delete(ctx, &momento.DeleteRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String(key),\n})\nif err != nil {\n\tpanic(err)\n}",csharp:'var result = await cacheClient.DeleteAsync("test-cache", "test-key");\nif (result is CacheDeleteResponse.Success)\n{\n    Console.WriteLine("Key \'test-key\' deleted successfully");\n}\nelse if (result is CacheDeleteResponse.Error error)\n{\n    throw new Exception($"An error occurred while attempting to delete key \'test-key\' from cache \'test-cache\': {error.ErrorCode}: {error}");\n}',php:'\n$delete_response = $cache_client->delete($cache_name, "test-key");\nif ($delete_response->asSuccess()) {\n    print("Key \'test-key\' deleted successfully\\n");\n} elseif ($err = $delete_response->asError()) {\n    print("An error occurred while attempting to delete key \'test-key\' from cache $cache_name: {$err->errorCode()} - {$err->message()}\\n");\n}',rust:'  cache_client.delete(cache_name, "key").await?;\n  println!("Value deleted");',elixir:'case Momento.CacheClient.delete(client, "test-cache", "test-key") do\n  {:ok, _} ->\n    IO.puts("Key \'test-key\' deleted successfully")\n\n  {:error, error} ->\n    IO.puts(\n      "An error occurred while attempting to delete key \'test-key\' from cache \'test-cache\': #{error.error_code}"\n    )\n\n    raise error\nend',swift:'let result = await cacheClient.delete(\n    cacheName: cacheName,\n    key: "key"\n)\nswitch result {\ncase .success(_):\n    print("Successfully deleted item in the cache")\ncase .error(let err):\n    print("Unable to delete item in the cache: \\(err)")\n    exit(1)\n}',dart:'final result = await cacheClient.delete("test-cache", "test-key");\nswitch (result) {\n  case DeleteError():\n    print("Error deleting key: $result");\n    exit(1);\n  case DeleteSuccess():\n    print("Successfully deleted key from cache");\n}',ts:""}),"\n",(0,r.jsx)(t.h3,{id:"increment",children:"Increment"}),"\n",(0,r.jsx)(t.p,{children:"Adds to the value of an item, if and only if the existing value is a UTF-8 string representing a base 10 integer. If the item does not exist, this method sets the item's value to the amount to increment by."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"The key under which the value is to be incremented."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"amount"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"The quantity to add to the value. May be positive, negative, or zero. Defaults to 1."})]})]})]}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"The resulting incremented value must be between -9223372036854775808 and 9223372036854775807, ie. a signed 64-bit integer. If not, there will be an error response."})}),"\n",(0,r.jsx)(i.r,{js:"await cacheClient.set(cacheName, 'test-key', '10');\nconst result = await cacheClient.increment(cacheName, 'test-key', 1);\nswitch (result.type) {\n  case CacheIncrementResponse.Success:\n    console.log(`Key 'test-key' incremented successfully. New value in key test-key: ${result.valueNumber()}`);\n    break;\n  case CacheIncrementResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to increment the value of key 'test-key' from cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:'cacheClient.set("test-cache", "test-key", "10").join();\nfinal IncrementResponse response = cacheClient.increment("test-cache", "test-key", 1).join();\nif (response instanceof IncrementResponse.Success success) {\n  System.out.println(\n      "Key \'test-key\' incremented successfully. New value in key test-key: "\n          + success.valueNumber());\n} else if (response instanceof IncrementResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to increment the value of key \'test-key\' from cache \'test-cache\': "\n          + error.getErrorCode(),\n      error);\n}',kotlin:"",go:'resp, err := client.Increment(ctx, &momento.IncrementRequest{\n\tCacheName: cacheName,\n\tField:     momento.String("key"),\n\tAmount:    1,\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.IncrementSuccess:\n\tlog.Printf("Incremented value is %d\\n", r.Value())\n}',csharp:"",php:"",rust:'  let response = cache_client.increment(cache_name, "key", 1).await?;\n  println!("Value incremented to {}", response.value);',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"ping",children:"Ping"}),"\n",(0,r.jsx)(t.p,{children:"Sends a ping to the server. This API can be used for checking connectivity to confirm that the client can connect to the server successfully."}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Success"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:"",csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"itemgettype",children:"ItemGetType"}),"\n",(0,r.jsx)(t.p,{children:"For a given key, returns the type (SCALAR, DICTIONARY, LIST, etc.) of the corresponding item, if it exists."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Byte"}),(0,r.jsx)(t.td,{children:"Key whose item type should be returned."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cache hit"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"type()"}),": enum: SCALAR, DICTIONARY, SET, LIST, SORTED_SET"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cache miss"}),"\n",(0,r.jsx)(t.li,{children:"Cache error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.itemGetType(cacheName, 'test-key');\nswitch (result.type) {\n  case CacheItemGetTypeResponse.Hit:\n    console.log(`Item type retrieved successfully: ${ItemType[result.itemType()]}`);\n    break;\n  case CacheItemGetTypeResponse.Miss:\n    console.log(\"Key 'test-key' was not found in cache '${cacheName}'\");\n    break;\n  case CacheItemGetTypeResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to get the type of key 'test-key' from cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.ItemGetType(ctx, &momento.ItemGetTypeRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.ItemGetTypeHit:\n\tlog.Printf("Type of item is %v\\n", r.Type())\ncase *responses.ItemGetTypeMiss:\n\tlog.Printf("Item does not exist in cache\\n")\n}',csharp:"",php:"",rust:'  let item_type: ItemType = cache_client\n      .item_get_type(cache_name, "key")\n      .await?\n      .try_into()\n      .expect("Expected an item type!");',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"keyexists",children:"KeyExists"}),"\n",(0,r.jsx)(t.p,{children:"Checks if a provided key exists in the cache."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Byte"}),(0,r.jsx)(t.td,{children:"Key which is to be checked for its existence in the cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Success"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"exists()"}),": Bool"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.keyExists(cacheName, 'test-key');\nswitch (result.type) {\n  case CacheKeyExistsResponse.Success:\n    console.log(\"Does 'test-key' exist in the cache?\", result.exists());\n    break;\n  case CacheKeyExistsResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call keyExists on key 'test-key' in cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:"",csharp:"",php:"",rust:'  let result = cache_client.key_exists(cache_name, "key").await?;\n  if result.exists {\n      println!("Key exists!");\n  } else {\n      println!("Key does not exist!");\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"keysexist",children:"KeysExist"}),"\n",(0,r.jsx)(t.p,{children:"Checks if provided keys exist in the cache."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"keys"}),(0,r.jsx)(t.td,{children:"String[] | Byte[]"}),(0,r.jsx)(t.td,{children:"Keys which are to be checked for their existence in the cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Success"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"exists()"}),": Bool[]"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.keysExist(cacheName, ['test-key1', 'test-key2']);\nswitch (result.type) {\n  case CacheKeysExistResponse.Success:\n    console.log(\"Do 'test-key1' and 'test-key2' exist in the cache?\", result.exists());\n    break;\n  case CacheKeysExistResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call keysExist on keys 'test-key1' and 'test-key2' in cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'keys := []momento.Value{momento.String("key1"), momento.String("key2")}\nresp, err := client.KeysExist(ctx, &momento.KeysExistRequest{\n\tCacheName: cacheName,\n\tKeys:      keys,\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.KeysExistSuccess:\n\tlog.Printf("Does each key exist in cache?\\n")\n\tfor _, exists := range r.Exists() {\n\t\tlog.Printf("key exists=%v\\n", exists)\n\t}\n}',csharp:"",php:"",rust:'  // Receive results as a HashMap\n  let result_map: HashMap<String, bool> = cache_client\n      .keys_exist(cache_name, vec!["key", "key1", "key2"])\n      .await?\n      .into();\n  println!("Do these keys exist? {result_map:#?}");\n\n  // Or receive results as a Vec\n  let result_list: Vec<bool> = cache_client\n      .keys_exist(cache_name, vec!["key", "key1", "key2"])\n      .await?\n      .into();\n  println!("Do these keys exist? {result_list:#?}");',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifabsent",children:"SetIfAbsent"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfPresent"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfAbsent"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfPresent"}),"."]})}),"\n",(0,r.jsx)(t.p,{children:"Associates the provided value to a cache item with a given key if the key does not already exist in the cache."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfAbsent(cacheName, 'test-key', 'test-field');\nswitch (result.type) {\n  case CacheSetIfAbsentResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfAbsentResponse.NotStored:\n    console.log(`Key 'test-key' already exists in cache ${cacheName}, so we did not overwrite it`);\n    break;\n  case CacheSetIfAbsentResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfAbsent for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfAbsent(ctx, &momento.SetIfAbsentRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfAbsentStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_absent(cache_name, "key", "value")\n      .await?\n  {\n      SetIfAbsentResponse::Stored => println!("Value stored"),\n      SetIfAbsentResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifpresent",children:"SetIfPresent"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfPresent"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfAbsent"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfPresent"}),"."]})}),"\n",(0,r.jsx)(t.p,{children:"Associates the provided value to a cache item with a given key if the key already exists in the cache."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfPresent(cacheName, 'test-key', 'test-field');\nswitch (result.type) {\n  case CacheSetIfPresentResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfPresentResponse.NotStored:\n    console.log(`Key 'test-key' does not exist in cache ${cacheName}, so we did not set the field`);\n    break;\n  case CacheSetIfPresentResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfPresent for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfPresent(ctx, &momento.SetIfPresentRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfPresentStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_present(cache_name, "key", "value")\n      .await?\n  {\n      SetIfPresentResponse::Stored => println!("Value stored"),\n      SetIfPresentResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifequal",children:"SetIfEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfNotEqual"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfEqual"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key already exists in the cache and the value in the cache is equal to the value supplied for ",(0,r.jsx)(t.code,{children:"equal"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"equal"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfEqual(cacheName, 'test-key', 'test-field', 'value-to-check');\nswitch (result.type) {\n  case CacheSetIfEqualResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfEqualResponse.NotStored:\n    console.log(\"Value of key 'test-key' does not equal 'value-to-check', so we did not set the field\");\n    break;\n  case CacheSetIfEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfEqual(ctx, &momento.SetIfEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tEqual:     momento.String("current-value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfEqualStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_equal(cache_name, "key", "new-value", "cached-value")\n      .await?\n  {\n      SetIfEqualResponse::Stored => println!("Value stored"),\n      SetIfEqualResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifnotequal",children:"SetIfNotEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfNotEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfEqual"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfNotEqual"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key does not already exist in the cache or the value in the cache is not equal to the value supplied for ",(0,r.jsx)(t.code,{children:"notEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"notEqual"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfNotEqual(cacheName, 'test-key', 'test-field', 'value-to-check');\nswitch (result.type) {\n  case CacheSetIfNotEqualResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfNotEqualResponse.NotStored:\n    console.log(\"Value of key 'test-key' equals 'value-to-check', so we did not set the field\");\n    break;\n  case CacheSetIfNotEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfNotEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfNotEqual(ctx, &momento.SetIfNotEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tNotEqual:  momento.String("current-value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfNotEqualStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_not_equal(cache_name, "key", "new-value", "cached-value")\n      .await?\n  {\n      SetIfNotEqualResponse::Stored => println!("Value stored"),\n      SetIfNotEqualResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifpresentandnotequal",children:"SetIfPresentAndNotEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfPresentAndNotEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfAbsentOrEqual"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfPresentAndNotEqual"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key already exists in the cache and the value in the cache is not equal to the value supplied for ",(0,r.jsx)(t.code,{children:"notEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"notEqual"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfPresentAndNotEqual(cacheName, 'test-key', 'test-field', 'value-to-check');\nswitch (result.type) {\n  case CacheSetIfPresentAndNotEqualResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfPresentAndNotEqualResponse.NotStored:\n    console.log(\n      `Key 'test-key' does not exist in cache ${cacheName} or equals 'value-to-check', so we did not set the field`\n    );\n    break;\n  case CacheSetIfPresentAndNotEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfPresentAndNotEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfPresentAndNotEqual(ctx, &momento.SetIfPresentAndNotEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tNotEqual:  momento.String("current-value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfPresentAndNotEqualStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_present_and_not_equal(cache_name, "key", "new-value", "cached-value")\n      .await?\n  {\n      SetIfPresentAndNotEqualResponse::Stored => println!("Value stored"),\n      SetIfPresentAndNotEqualResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifabsentorequal",children:"SetIfAbsentOrEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfAbsentOrEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetIfPresentAndNotEqual"})," instead with ",(0,r.jsx)(t.code,{children:"SetIfAbsentOrEqual"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key does not already exist in the cache or the value in the cache is equal to the value supplied for ",(0,r.jsx)(t.code,{children:"equal"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"equal"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Stored"}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfAbsentOrEqual(cacheName, 'test-key', 'test-field', 'value-to-check');\nswitch (result.type) {\n  case CacheSetIfAbsentOrEqualResponse.Stored:\n    console.log(\"Field 'test-field' set in key 'test-key'\");\n    break;\n  case CacheSetIfAbsentOrEqualResponse.NotStored:\n    console.log(\n      `Key 'test-key' exists in cache ${cacheName} and is not equal to 'value-to-check', so we did not set the field`\n    );\n    break;\n  case CacheSetIfAbsentOrEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfAbsentOrEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfAbsentOrEqual(ctx, &momento.SetIfAbsentOrEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tEqual:     momento.String("current-value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.SetIfAbsentOrEqualStored:\n\tlog.Printf("Successfully set key in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .set_if_absent_or_equal(cache_name, "key", "new-value", "cached-value")\n      .await?\n  {\n      SetIfAbsentOrEqualResponse::Stored => println!("Value stored"),\n      SetIfAbsentOrEqualResponse::NotStored => println!("Value not stored"),\n  }',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"getwithhash",children:"GetWithHash"}),"\n",(0,r.jsx)(t.p,{children:"Get the cache value and hash of the cache value stored for the given key."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Hit","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"valueString()"}),": the value of the item stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"valueByte()"}),": the value of the item stored in the cache returned as bytes"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Miss"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const getResponse = await cacheClient.getWithHash(cacheName, 'test-key');\n// simplified style; assume the value was found\nconsole.log(`cache hit: value: ${getResponse.value()!}, hash: ${getResponse.hash()!}`);\n\n// pattern-matching style; safer for production code\nswitch (getResponse.type) {\n  case CacheGetWithHashResponse.Hit:\n    console.log(\n      `Retrieved value for key 'test-key': ${getResponse.valueString()} with hash: ${getResponse.hashString()}`\n    );\n    break;\n  case CacheGetWithHashResponse.Miss:\n    console.log(`Key 'test-key' was not found in cache '${cacheName}'`);\n    break;\n  case CacheGetWithHashResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to get key 'test-key' from cache '${cacheName}': ${getResponse.errorCode()}: ${getResponse.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.GetWithHash(ctx, &momento.GetWithHashRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.GetWithHashHit:\n\tlog.Printf("Successfully got value %s with hash %s\\n", r.ValueString(), r.HashString())\ncase *responses.GetWithHashMiss:\n\tlog.Printf("Key does not exist in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setwithhash",children:"SetWithHash"}),"\n",(0,r.jsx)(t.p,{children:"Associates the provided value to a cache item with a given key and returns the hash of the value."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Stored","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setWithHash(cacheName, 'test-key', 'test-value');\nswitch (result.type) {\n  case CacheSetWithHashResponse.Stored:\n    console.log(`Successfully set Key 'test-key' in cache, item has new hash '${result.hashString()}`);\n    break;\n  case CacheSetWithHashResponse.NotStored:\n    console.log(\"Unable to set Key 'test-key' \");\n    break;\n  case CacheSetWithHashResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to store key 'test-key' in cache '${cacheName}': ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetWithHash(ctx, &momento.SetWithHashRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.SetWithHashStored:\n\tlog.Printf("Successfully set key in cache, item has new hash %s\\n", r.HashString())\n\thashValue = r.HashString()\ncase *responses.SetWithHashNotStored:\n\tlog.Printf("Unable to set key in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifpresentandhashequal",children:"SetIfPresentAndHashEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfPresentAndHashEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetWithHash"})," and ",(0,r.jsx)(t.code,{children:"GetWithHash"})," instead for unconditional sets/gets with hash values."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key exists in the cache and the hash value of the stored item is equal to the hash value supplied for ",(0,r.jsx)(t.code,{children:"hashEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hashEqual"}),(0,r.jsx)(t.td,{children:"Bytes"}),(0,r.jsx)(t.td,{children:"The hash of the value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Stored","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"cacheClient: CacheClient,\ncacheName: string,\nhashValue: Uint8Array\n{\nconst result = await cacheClient.setIfPresentAndHashEqual(cacheName, 'test-key', 'test-value', hashValue);\nswitch (result.type) {\n  case CacheSetIfPresentAndHashEqualResponse.Stored:\n    console.log(`Value 'test-value' set in key 'test-key' with hash: ${result.hashString()}`);\n    break;\n  case CacheSetIfPresentAndHashEqualResponse.NotStored:\n    console.log(\n      `Key 'test-key' exists in cache ${cacheName} or is not equal to hashValue, so we did not set the field`\n    );\n    break;\n  case CacheSetIfPresentAndHashEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfPresentAndHashEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfPresentAndHashEqual(ctx, &momento.SetIfPresentAndHashEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tHashEqual: momento.String(hashValue),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.SetIfPresentAndHashEqualStored:\n\tlog.Printf("Successfully set key in cache, item has new hash %s\\n", r.HashString())\ncase *responses.SetIfPresentAndHashEqualNotStored:\n\tlog.Printf("Unable to set key in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifpresentandhashnotequal",children:"SetIfPresentAndHashNotEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfPresentAndHashNotEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetWithHash"})," and ",(0,r.jsx)(t.code,{children:"GetWithHash"})," instead for unconditional sets/gets with hash values."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if the key exists in the cache and the hash value of the stored item is not equal to the hash value supplied for ",(0,r.jsx)(t.code,{children:"hashNotEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hashNotEqual"}),(0,r.jsx)(t.td,{children:"Bytes"}),(0,r.jsx)(t.td,{children:"The hash of the value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Stored","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfPresentAndHashNotEqual(ctx, &momento.SetIfPresentAndHashNotEqualRequest{\n\tCacheName:    cacheName,\n\tKey:          momento.String("key"),\n\tValue:        momento.String("value"),\n\tHashNotEqual: momento.String(hashValue),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.SetIfPresentAndHashNotEqualStored:\n\tlog.Printf("Successfully set key in cache, item has new hash %s\\n", r.HashString())\ncase *responses.SetIfPresentAndHashNotEqualNotStored:\n\tlog.Printf("Unable to set key in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifabsentorhashequal",children:"SetIfAbsentOrHashEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfAbsentOrHashEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetWithHash"})," and ",(0,r.jsx)(t.code,{children:"GetWithHash"})," instead for unconditional sets/gets with hash values."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if (1) the key does not already exist in the cache or (2) the key exists and the hash value of the stored item is equal to the hash value supplied for ",(0,r.jsx)(t.code,{children:"hashEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hashEqual"}),(0,r.jsx)(t.td,{children:"Bytes"}),(0,r.jsx)(t.td,{children:"The hash of the value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Stored","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"const result = await cacheClient.setIfAbsentOrHashEqual(cacheName, 'test-key', 'test-value', hashValue);\nswitch (result.type) {\n  case CacheSetIfAbsentOrHashEqualResponse.Stored:\n    console.log(`Value 'test-value' set in key 'test-key' with hash: ${result.hashString()}`);\n    break;\n  case CacheSetIfAbsentOrHashEqualResponse.NotStored:\n    console.log(\n      `Key 'test-key' exists in cache ${cacheName} and is not equal to hashValue, so we did not set the field`\n    );\n    break;\n  case CacheSetIfAbsentOrHashEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfAbsentOrHashEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfAbsentOrHashEqual(ctx, &momento.SetIfAbsentOrHashEqualRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tValue:     momento.String("value"),\n\tHashEqual: momento.String(hashValue),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.SetIfAbsentOrHashEqualStored:\n\tlog.Printf("Successfully set key in cache, item has new hash %s\\n", r.HashString())\ncase *responses.SetIfAbsentOrHashEqualNotStored:\n\tlog.Printf("Unable to set key in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"setifabsentorhashnotequal",children:"SetIfAbsentOrHashNotEqual"}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Do NOT use check-and-set (CAS) APIs such as ",(0,r.jsx)(t.code,{children:"SetIfAbsentOrHashNotEqual"})," with scalar or non-CAS APIs such as ",(0,r.jsx)(t.code,{children:"Set"})," or ",(0,r.jsx)(t.code,{children:"Delete"}),".\nDoing so will result in undefined consistency behaviors. Use ",(0,r.jsx)(t.code,{children:"SetWithHash"})," and ",(0,r.jsx)(t.code,{children:"GetWithHash"})," instead for unconditional sets/gets with hash values."]})}),"\n",(0,r.jsxs)(t.p,{children:["Associates the provided value to a cache item with a given key if (1) the key does not already exist in the cache or (2) the key exists and the hash value of the stored item is not equal to the hash value supplied for ",(0,r.jsx)(t.code,{children:"hashNotEqual"}),"."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key to be set."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"value"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The value to be stored."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"hashNotEqual"}),(0,r.jsx)(t.td,{children:"Bytes"}),(0,r.jsx)(t.td,{children:"The hash of the value to compare with."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttlSeconds"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to Live for the item in Cache."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Stored","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashString()"}),": the hash of the value stored in the cache returned as a string"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"hashByte()"}),": the hash of the value stored in the cache returned as bytes"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"NotStored"}),"\n",(0,r.jsx)(t.li,{children:"Error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"cacheClient: CacheClient,\ncacheName: string,\nhashValue: Uint8Array\n{\nconst result = await cacheClient.setIfAbsentOrHashNotEqual(cacheName, 'test-key', 'test-value', hashValue);\nswitch (result.type) {\n  case CacheSetIfAbsentOrHashNotEqualResponse.Stored:\n    console.log(`Value 'test-value' set in key 'test-key' with hash: ${result.hashString()}`);\n    break;\n  case CacheSetIfAbsentOrHashNotEqualResponse.NotStored:\n    console.log(`Key 'test-key' exists in cache ${cacheName} and is equal to hashValue, so we did not set the field`);\n    break;\n  case CacheSetIfAbsentOrHashNotEqualResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call setIfAbsentOrHashEqual for the key 'test-key' in cache cacheName: ${result.errorCode()}: ${result.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := client.SetIfAbsentOrHashNotEqual(ctx, &momento.SetIfAbsentOrHashNotEqualRequest{\n\tCacheName:    cacheName,\n\tKey:          momento.String("key"),\n\tValue:        momento.String("value"),\n\tHashNotEqual: momento.String(hashValue),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.SetIfAbsentOrHashNotEqualStored:\n\tlog.Printf("Successfully set key in cache, item has new hash %s\\n", r.HashString())\ncase *responses.SetIfAbsentOrHashNotEqualNotStored:\n\tlog.Printf("Unable to set key in cache\\n")\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h2,{id:"time-to-live-apis",children:"Time to Live APIs"}),"\n",(0,r.jsx)(t.p,{children:"These APIs apply across all cache types."}),"\n",(0,r.jsx)(t.h3,{id:"updatettl",children:"UpdateTtl"}),"\n",(0,r.jsx)(t.p,{children:"Overwrites the TTL of a cache item with the provided value in seconds."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key under which the value's TTL is to be updated."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttl"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to live that you want to update in cache in seconds."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:'resp, err := client.UpdateTtl(ctx, &momento.UpdateTtlRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tTtl:       time.Duration(9999),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.UpdateTtlSet:\n\tlog.Printf("Successfully updated TTL for key\\n")\ncase *responses.UpdateTtlMiss:\n\tlog.Printf("Key does not exist in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .update_ttl(cache_name, "key", Duration::from_secs(10))\n      .await?\n  {\n      UpdateTtlResponse::Set => println!("TTL updated"),\n      UpdateTtlResponse::Miss => println!("Cache miss, unable to find key to update TTL"),\n  };',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"increasettl",children:"IncreaseTtl"}),"\n",(0,r.jsx)(t.p,{children:"Increase the TTL seconds for a key to the provided value only if it would increase the TTL."}),"\n",(0,r.jsx)(t.p,{children:"Examples"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"If the TTL is 5 seconds and is increased to 6 seconds, the new TTL will be 6 seconds."}),"\n",(0,r.jsx)(t.li,{children:"If the TTL is 5 seconds and is increased to 3 seconds, the TTL will not be increased."}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key under which the value's TTL is to be increased."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttl"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to live that you want to increase to."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:'resp, err := client.IncreaseTtl(ctx, &momento.IncreaseTtlRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tTtl:       time.Duration(9999),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.IncreaseTtlSet:\n\tlog.Printf("Successfully increased TTL for key\\n")\ncase *responses.IncreaseTtlMiss:\n\tlog.Printf("Key does not exist in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .increase_ttl(cache_name, "key", Duration::from_secs(5))\n      .await?\n  {\n      IncreaseTtlResponse::Set => println!("TTL updated"),\n      IncreaseTtlResponse::NotSet => println!("unable to increase TTL"),\n      IncreaseTtlResponse::Miss => println!("Cache miss, unable to find key to increase TTL"),\n  };',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"decreasettl",children:"DecreaseTtl"}),"\n",(0,r.jsx)(t.p,{children:"Decrease the TTL seconds for a key to the provided value only if it would decrease the TTL."}),"\n",(0,r.jsx)(t.p,{children:"Examples"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"If the TTL is 5 seconds and is decreased to 3 seconds, the new TTL will be 3 seconds."}),"\n",(0,r.jsx)(t.li,{children:"If the TTL is 5 seconds and is decreased to 6 seconds, the TTL will not be decreased."}),"\n"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Bytes"}),(0,r.jsx)(t.td,{children:"The key under which the value's TTL is to be decreased."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"ttl"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"Time to live that you want to decrease to."})]})]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:'resp, err := client.DecreaseTtl(ctx, &momento.DecreaseTtlRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n\tTtl:       time.Duration(9999),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch resp.(type) {\ncase *responses.DecreaseTtlSet:\n\tlog.Printf("Successfully decreased TTL for key\\n")\ncase *responses.DecreaseTtlMiss:\n\tlog.Printf("Key does not exist in cache\\n")\n}',csharp:"",php:"",rust:'  match cache_client\n      .decrease_ttl(cache_name, "key", Duration::from_secs(3))\n      .await?\n  {\n      DecreaseTtlResponse::Set => println!("TTL updated"),\n      DecreaseTtlResponse::NotSet => println!("unable to decrease TTL"),\n      DecreaseTtlResponse::Miss => println!("Cache miss, unable to find key to decrease TTL"),\n  };',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h3,{id:"itemgetttl",children:"ItemGetTtl"}),"\n",(0,r.jsx)(t.p,{children:"For a given key, returns the duration of time remaining (Time To Live) before the item expires from the cache."}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cacheName"}),(0,r.jsx)(t.td,{children:"String"}),(0,r.jsx)(t.td,{children:"Name of the cache."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"key"}),(0,r.jsx)(t.td,{children:"String | Byte"}),(0,r.jsx)(t.td,{children:"Key whose item type should be returned."})]})]})]}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"Method response object"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cache hit"}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"remainingTtl()"}),": Duration"]}),"\n"]}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Cache miss"}),"\n",(0,r.jsx)(t.li,{children:"Cache error"}),"\n"]}),(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/response-objects",children:"response objects"})," for specific information."]})]}),"\n",(0,r.jsx)(i.r,{js:"",python:"",java:"",kotlin:"",go:'resp, err := client.ItemGetTtl(ctx, &momento.ItemGetTtlRequest{\n\tCacheName: cacheName,\n\tKey:       momento.String("key"),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *responses.ItemGetTtlHit:\n\tlog.Printf("TTL for key is %d\\n", r.RemainingTtl().Milliseconds())\ncase *responses.ItemGetTtlMiss:\n\tlog.Printf("Key does not exist in cache\\n")\n}',csharp:"",php:"",rust:'  let remaining_ttl: Duration = cache_client\n      .item_get_ttl(cache_name, "key")\n      .await?\n      .try_into()\n      .expect("Expected an item ttl!");',elixir:"",swift:"",dart:"",ts:""}),"\n",(0,r.jsx)(t.h2,{id:"collection-data-types",children:"Collection data types"}),"\n",(0,r.jsx)(t.p,{children:"Collections may contain different types of structures depending on your use case. Supported data types are:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/dictionary-collections",children:"Dictionaries"})," are used to store unordered field",":value"," pairs."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/list-collections",children:"Lists"})," are a collection of ordered elements, sorted in the sequence each element was inserted."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/set-collections",children:"Sets"})," are an unordered collection of unique elements in string format."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"/cache/develop/api-reference/sorted-set-collections",children:"Sorted Sets"})," are an ordered collection of unique elements.  Each element contains a value",":score"," pair."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For more in-depth information on usage, see ",(0,r.jsx)(t.a,{href:"/cache/develop/basics/datatypes",children:"collection data types"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"current-status-of-api-support-in-sdks",children:"Current status of API support in SDKs"}),"\n",(0,r.jsxs)(t.p,{children:["For the current status of API support in various SDK languages, see the ",(0,r.jsx)(t.a,{href:"/cache/develop/language-support/",children:"language support page"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);