"use strict";(self.webpackChunkmomento_docs=self.webpackChunkmomento_docs||[]).push([[5533],{2407:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>t,metadata:()=>c,toc:()=>h});var o=s(74848),i=s(28453),r=(s(51441),s(35347));const t={sidebar_position:2,title:"Auth API reference information",sidebar_label:"Auth",description:"Learn the Auth API calls you need to know about and how to use them with Momento services."},a="Auth API reference",c={id:"topics/api-reference/auth",title:"Auth API reference information",description:"Learn the Auth API calls you need to know about and how to use them with Momento services.",source:"@site/docs/topics/api-reference/auth.md",sourceDirName:"topics/api-reference",slug:"/topics/api-reference/auth",permalink:"/topics/api-reference/auth",draft:!1,unlisted:!1,editUrl:"https://github.com/momentohq/public-dev-docs/tree/main/docs/topics/api-reference/auth.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Auth API reference information",sidebar_label:"Auth",description:"Learn the Auth API calls you need to know about and how to use them with Momento services."},sidebar:"topicsSidebar",previous:{title:"API Reference",permalink:"/topics/api-reference/"},next:{title:"Webhooks",permalink:"/topics/api-reference/webhooks"}},l={},h=[{value:"AuthClient Methods",id:"authclient-methods",level:2},{value:"GenerateApiKey",id:"generateapikey",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"RefreshApiKey",id:"refreshapikey",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"GenerateDisposableToken",id:"generatedisposabletoken",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Optional Parameters",id:"optional-parameters",level:4},{value:"Returns",id:"returns-2",level:4},{value:"PermissionScope objects",id:"permissionscope-objects",level:2},{value:"PermissionScope",id:"permissionscope",level:3},{value:"Permission objects",id:"permission-objects",level:3},{value:"CachePermission",id:"cachepermission",level:3},{value:"PermissionScope example for a CachePermission object",id:"permissionscope-example-for-a-cachepermission-object",level:4},{value:"TopicPermission",id:"topicpermission",level:3},{value:"PermissionScope example for a TopicPermission object",id:"permissionscope-example-for-a-topicpermission-object",level:4},{value:"DisposableTokenScope objects",id:"disposabletokenscope-objects",level:2},{value:"DisposableTokenCachePermissions",id:"disposabletokencachepermissions",level:3},{value:"Example DisposableTokenScope object",id:"example-disposabletokenscope-object",level:4},{value:"FAQ",id:"faq",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components},{Details:s}=n;return s||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"auth-api-reference",children:"Auth API reference"})}),"\n",(0,o.jsx)(n.p,{children:"The auth APIs create and manage API keys and tokens for Momento services. These auth mechanisms can be scoped to have one or more permissions to grant access to one or more caches or topics."}),"\n",(0,o.jsx)("img",{src:"/img/momento-auth-tokens.png",width:"60%"}),"\n",(0,o.jsx)(n.h2,{id:"authclient-methods",children:"AuthClient Methods"}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)("div",{class:"row",children:[(0,o.jsxs)("div",{class:"col col--4",style:{paddingRight:"20px"},children:[(0,o.jsx)(n.h3,{id:"generateapikey",children:"GenerateApiKey"}),(0,o.jsx)(n.p,{children:"Generates a new Momento auth token with the specified permissions and expiry."}),(0,o.jsx)(n.h4,{id:"parameters",children:"Parameters"}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"scope"})," - ",(0,o.jsx)(n.a,{href:"#permissionscope-objects",children:(0,o.jsx)(n.em,{children:"PermissionScope"})}),": The permissions to grant to the new token. Pre-built PermissionScope objects are provided by the SDKs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"expiresIn"})," - ",(0,o.jsx)(n.em,{children:"ExpiresIn object"}),": The number of seconds until the token expires or an ExpiresIn object representing a duration by calling the ",(0,o.jsx)(n.code,{children:"ExpiresIn.never()"}),", ",(0,o.jsx)(n.code,{children:"ExpiresIn.minutes()"}),", or ",(0,o.jsx)(n.code,{children:"ExpiresIn.hours()"})," methods."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"returns",children:"Returns"}),(0,o.jsx)(n.hr,{}),(0,o.jsx)(n.p,{children:"One of the following:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Success"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"authToken"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The new auth token."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"refreshToken"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": A refresh token that can be used with the ",(0,o.jsx)(n.a,{href:"#refreshapikey",children:"RefreshApiKey API"})," to refresh a token before it expires."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"endpoint"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The HTTP endpoint the Momento client should use when making requests."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"expiresAt"}),"- ",(0,o.jsx)(n.em,{children:"ExpiresAt object"}),": The timestamp at which the token will expire."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Error"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["See ",(0,o.jsx)(n.a,{href:"/topics/api-reference/response-objects",children:"response objects"})," for specific information."]}),"\n"]}),"\n"]}),"\n"]})]}),(0,o.jsx)("div",{class:"col col--8",children:(0,o.jsx)(r.r,{js:"// Generate a token that allows all data plane APIs on all caches and topics.\nconst allDataRWTokenResponse = await authClient.generateApiKey(AllDataReadWrite, ExpiresIn.minutes(30));\nswitch (allDataRWTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with AllDataReadWrite scope!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${allDataRWTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${allDataRWTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${allDataRWTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with AllDataReadWrite scope: ${allDataRWTokenResponse.errorCode()}: ${allDataRWTokenResponse.toString()}`\n    );\n}\n\n// Generate a token that can only call read-only data plane APIs on a specific cache foo. No topic apis (publish/subscribe) are allowed.\nconst singleCacheROTokenResponse = await authClient.generateApiKey(\n  TokenScopes.cacheReadOnly('foo'),\n  ExpiresIn.minutes(30)\n);\nswitch (singleCacheROTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with read-only access to cache foo!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${singleCacheROTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${singleCacheROTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${singleCacheROTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with single cache read-only scope: ${singleCacheROTokenResponse.errorCode()}: ${singleCacheROTokenResponse.toString()}`\n    );\n}\n\n// Generate a token that can call all data plane APIs on all caches. No topic apis (publish/subscribe) are allowed.\nconst allCachesRWTokenResponse = await authClient.generateApiKey(\n  TokenScopes.cacheReadWrite(AllCaches),\n  ExpiresIn.minutes(30)\n);\nswitch (allCachesRWTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with read-write access to all caches!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${allCachesRWTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${allCachesRWTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${allCachesRWTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with all caches read-write scope: ${allCachesRWTokenResponse.errorCode()}: ${allCachesRWTokenResponse.toString()}`\n    );\n}\n\n// Generate a token that can call publish and subscribe on all topics within cache bar\nconst singleCacheAllTopicsRWTokenResponse = await authClient.generateApiKey(\n  TokenScopes.topicPublishSubscribe({name: 'bar'}, AllTopics),\n  ExpiresIn.minutes(30)\n);\nswitch (singleCacheAllTopicsRWTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with publish-subscribe access to all topics within cache bar!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${singleCacheAllTopicsRWTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${singleCacheAllTopicsRWTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${singleCacheAllTopicsRWTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with read-write scope for all topics in a single cache: ${singleCacheAllTopicsRWTokenResponse.errorCode()}: ${singleCacheAllTopicsRWTokenResponse.toString()}`\n    );\n}\n\n// Generate a token that can only call subscribe on topic where_is_mo within cache mo_nuts\nconst oneCacheOneTopicRWTokenResponse = await authClient.generateApiKey(\n  TokenScopes.topicSubscribeOnly('mo_nuts', 'where_is_mo'),\n  ExpiresIn.minutes(30)\n);\nswitch (oneCacheOneTopicRWTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with subscribe-only access to topic where_is_mo within cache mo_nuts!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${oneCacheOneTopicRWTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${oneCacheOneTopicRWTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${oneCacheOneTopicRWTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with read-write scope for single topic in a single cache: ${oneCacheOneTopicRWTokenResponse.errorCode()}: ${oneCacheOneTopicRWTokenResponse.toString()}`\n    );\n}\n\n// Generate a token with multiple permissions\nconst cachePermission1 = {\n  role: CacheRole.ReadWrite, // Managed role that grants access to read as well as write apis on caches\n  cache: 'acorns', // Scopes the access to a single cache named 'acorns'\n};\nconst cachePermission2 = {\n  role: CacheRole.ReadOnly, // Managed role that grants access to only read data apis on caches\n  cache: AllCaches, // Built-in value for access to all caches in the account\n};\nconst topicPermission1 = {\n  role: TopicRole.PublishSubscribe, // Managed role that grants access to subscribe as well as publish apis\n  cache: 'walnuts', // Scopes the access to a single cache named 'walnuts'\n  topic: 'mo_favorites', // Scopes the access to a single topic named 'mo_favorites' within cache 'walnuts'\n};\nconst topicPermission2 = {\n  role: TopicRole.SubscribeOnly, // Managed role that grants access to only subscribe api\n  cache: AllCaches, // Built-in value for all cache(s) in the account.\n  topic: AllTopics, // Built-in value for access to all topics in the listed cache(s).\n};\n\nconst permissions = {\n  permissions: [cachePermission1, cachePermission2, topicPermission1, topicPermission2],\n};\n\nconst multiplePermsTokenResponse = await authClient.generateApiKey(permissions, ExpiresIn.minutes(30));\nswitch (multiplePermsTokenResponse.type) {\n  case GenerateApiKeyResponse.Success:\n    console.log('Generated an API key with multiple cache and topic permissions!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${multiplePermsTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`Refresh token starts with: ${multiplePermsTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Expires At: ${multiplePermsTokenResponse.expiresAt.epoch()}`);\n    break;\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with multiple permissions: ${multiplePermsTokenResponse.errorCode()}: ${multiplePermsTokenResponse.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'// Generate a token that allows all data plane APIs on all caches and topics.\nresp, err := authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.AllDataReadWrite,\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key with AllDataReadWrite scope!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}\n\n// Generate a token that can only call read-only data plane APIs on a specific cache foo. No topic apis (publish/subscribe) are allowed.\nresp, err = authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.CacheReadOnly(momento.CacheName{Name: "foo"}),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key with read-only access to cache foo!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}\n\n// Generate a token that can call all data plane APIs on all caches. No topic apis (publish/subscribe) are allowed.\nresp, err = authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.CacheReadWrite(momento.AllCaches{}),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key with read-write access to all caches!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}\n\n// Generate a token that can call publish and subscribe on all topics within cache bar\nresp, err = authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.TopicPublishSubscribe(momento.CacheName{Name: "bar"}, momento.AllTopics{}),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key publish-subscribe access to all topics within cache bar!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}\n\n// Generate a token that can only call subscribe on topic where_is_mo within cache mo_nuts\nresp, err = authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.TopicSubscribeOnly(momento.CacheName{Name: "mo_nuts"}, momento.TopicName{Name: "where_is_mo"}),\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key with subscribe-only access to topic where_is_mo within cache mo_nuts!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}\n\n// Generate a token with multiple permissions\ncachePermission1 := momento.CachePermission{\n\tCache: momento.CacheName{Name: "acorns"}, // Scopes the access to a single cache named \'acorns\'\n\tRole:  momento.ReadWrite,                 // Managed role that grants access to read as well as write apis on caches\n}\ncachePermission2 := momento.CachePermission{\n\tCache: momento.AllCaches{}, // Built-in value for access to all caches in the account\n\tRole:  momento.ReadOnly,    // Managed role that grants access to only read data apis on caches\n}\ntopicPermission1 := momento.TopicPermission{\n\tCache: momento.CacheName{Name: "walnuts"},      // Scopes the access to a single cache named \'walnuts\'\n\tTopic: momento.TopicName{Name: "mo_favorites"}, // Scopes the access to a single topic named \'mo_favorites\' within cache \'walnuts\'\n\tRole:  momento.PublishSubscribe,                // Managed role that grants access to subscribe as well as publish apis\n}\ntopicPermission2 := momento.TopicPermission{\n\tCache: momento.AllCaches{},   // Built-in value for all cache(s) in the account.\n\tTopic: momento.AllTopics{},   // Built-in value for access to all topics in the listed cache(s).\n\tRole:  momento.SubscribeOnly, // Managed role that grants access to only subscribe api\n}\npermissions := []momento.Permission{\n\tcachePermission1, cachePermission2, topicPermission1, topicPermission2,\n}\n\nresp, err = authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope: momento.Permissions{\n\t\tPermissions: permissions,\n\t},\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := resp.(type) {\ncase *auth_resp.GenerateApiKeySuccess:\n\tlog.Printf("Successfully generated an API key with multiple cache and topic permissions!\\n")\n\tlog.Printf("API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)("div",{class:"row",children:[(0,o.jsxs)("div",{class:"col col--4",style:{paddingRight:"20px"},children:[(0,o.jsx)(n.h3,{id:"refreshapikey",children:"RefreshApiKey"}),(0,o.jsx)(n.p,{children:"Refreshes an existing, unexpired Momento API key. Produces a new API key with the same permissions and expiry duration as the original API key."}),(0,o.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"refreshToken"})," - ",(0,o.jsx)(n.em,{children:"String"}),": The refresh token that was provided when the original API key was generated."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"returns-1",children:"Returns"}),(0,o.jsx)(n.hr,{}),(0,o.jsx)(n.p,{children:"One of the following:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Success"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"apiKey"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The new auth token."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"refreshToken"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": A refresh token that can be used with the ",(0,o.jsx)(n.a,{href:"#refreshapikey",children:"RefreshApiKey API"})," to refresh a token before it expires."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"endpoint"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The HTTP endpoint the Momento client should use when making requests."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"expiresAt"}),"- ",(0,o.jsx)(n.em,{children:"ExpiresAt object"}),": The timestamp at which the token will expire."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Error"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["See ",(0,o.jsx)(n.a,{href:"/topics/api-reference/response-objects",children:"response objects"})," for specific information."]}),"\n"]}),"\n"]}),"\n"]})]}),(0,o.jsx)("div",{class:"col col--8",children:(0,o.jsx)(r.r,{js:"const generateTokenResponse = await authClient.generateApiKey(AllDataReadWrite, ExpiresIn.minutes(30));\n\nlet successResponse: GenerateApiKey.Success;\nswitch (generateTokenResponse.type) {\n  case GenerateApiKeyResponse.Success: {\n    successResponse = generateTokenResponse;\n    break;\n  }\n  case GenerateApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey: ${generateTokenResponse.errorCode()}: ${generateTokenResponse.toString()}`\n    );\n}\n\nconsole.log('Generated API key; refreshing!');\nconst refreshAuthClient = new AuthClient({\n  credentialProvider: CredentialProvider.fromString({apiKey: successResponse.apiKey}),\n});\nconst refreshTokenResponse = await refreshAuthClient.refreshApiKey(successResponse.refreshToken);\nswitch (refreshTokenResponse.type) {\n  case RefreshApiKeyResponse.Success:\n    console.log('API key refreshed!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`Refreshed API key starts with: ${refreshTokenResponse.apiKey.substring(0, 10)}`);\n    console.log(`New refresh token starts with: ${refreshTokenResponse.refreshToken.substring(0, 10)}`);\n    console.log(`Refreshed API key expires At: ${refreshTokenResponse.expiresAt.epoch()}`);\n    break;\n  case RefreshApiKeyResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call refreshApiKey: ${refreshTokenResponse.errorCode()}: ${refreshTokenResponse.toString()}`\n    );\n}",python:"",java:"",kotlin:"",go:'resp, err := authClient.GenerateApiKey(ctx, &momento.GenerateApiKeyRequest{\n\tExpiresIn: utils.ExpiresInMinutes(30),\n\tScope:     momento.AllDataReadWrite,\n})\nif err != nil {\n\tpanic(err)\n}\ngenerateApiKeySuccess := resp.(*auth_resp.GenerateApiKeySuccess)\n\nnewCredProvider, err := auth.FromString(generateApiKeySuccess.ApiKey)\nif err != nil {\n\tpanic(err)\n}\n\nrefreshAuthClient, err := momento.NewAuthClient(config.AuthDefault(), newCredProvider)\nif err != nil {\n\tpanic(err)\n}\n\nrefreshResp, err := refreshAuthClient.RefreshApiKey(ctx, &momento.RefreshApiKeyRequest{\n\tRefreshToken: generateApiKeySuccess.RefreshToken,\n})\nif err != nil {\n\tpanic(err)\n}\nswitch r := refreshResp.(type) {\ncase *auth_resp.RefreshApiKeySuccess:\n\tlog.Printf("Successfully refreshed API key!\\n")\n\tlog.Printf("Refreshed API key expires at: %d\\n", r.ExpiresAt.Epoch())\n}',csharp:"",php:"",rust:"",elixir:"",swift:"",dart:"",ts:""})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)("div",{class:"row",children:[(0,o.jsxs)("div",{class:"col col--4",style:{paddingRight:"20px"},children:[(0,o.jsx)(n.h3,{id:"generatedisposabletoken",children:"GenerateDisposableToken"}),(0,o.jsx)(n.p,{children:"Generates a new disposable Momento auth token with the specified permissions and expiry.\nDisposable tokens differ from the usual Momento auth token in several key ways:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["They cannot be generated in the console, they can only be generated programmatically. The token that's used for the ",(0,o.jsx)(n.code,{children:"generateDisposableToken"})," API call must be a token with Super User scope generated via the Momento console."]}),"\n",(0,o.jsx)(n.li,{children:"They must expire within one hour."}),"\n",(0,o.jsx)(n.li,{children:"They cannot be refreshed and thus do not come with a refresh token."}),"\n",(0,o.jsx)(n.li,{children:"Permissions are specified using DisposableTokenScope object."}),"\n"]}),(0,o.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"scope"})," - ",(0,o.jsx)(n.a,{href:"#disposabletokenscope-objects",children:(0,o.jsx)(n.em,{children:"DisposableTokenScope"})}),": The permissions to grant to the new disposable token. Pre-built DisposableTokenScope objects are provided by the SDKs."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"expiresIn"})," - ",(0,o.jsx)(n.em,{children:"ExpiresIn object"}),": The number of seconds until the token expires or an ExpiresIn object representing a duration by calling the ExpiresIn.minutes() or ExpiresIn.hours(1) methods. Disposable tokens must expire within 1 hour."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"optional-parameters",children:"Optional Parameters"}),(0,o.jsx)(n.hr,{}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"tokenId"})," - ",(0,o.jsx)(n.em,{children:"String"}),": A user-provided string that can help identify which messages were published with which disposable token."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"returns-2",children:"Returns"}),(0,o.jsx)(n.hr,{}),(0,o.jsx)(n.p,{children:"One of the following:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Success"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"authToken"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The new disposable auth token."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"endpoint"}),"- ",(0,o.jsx)(n.em,{children:"String"}),": The HTTP endpoint the Momento client should use when making requests."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"expiresAt"}),"- ",(0,o.jsx)(n.em,{children:"ExpiresAt object"}),": The timestamp at which the token will expire."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Error"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["See ",(0,o.jsx)(n.a,{href:"/topics/api-reference/response-objects",children:"response objects"})," for specific information."]}),"\n"]}),"\n"]}),"\n"]})]}),(0,o.jsx)("div",{class:"col col--8",children:(0,o.jsx)(r.r,{js:"// Generate a disposable token with read-write access to a specific key in one cache\nconst oneKeyOneCacheToken = await authClient.generateDisposableToken(\n  DisposableTokenScopes.cacheKeyReadWrite('squirrels', 'mo'),\n  ExpiresIn.minutes(30)\n);\nswitch (oneKeyOneCacheToken.type) {\n  case GenerateDisposableTokenResponse.Success:\n    console.log('Generated a disposable API key with access to the \"mo\" key in the \"squirrels\" cache!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${oneKeyOneCacheToken.authToken.substring(0, 10)}`);\n    console.log(`Expires At: ${oneKeyOneCacheToken.expiresAt.epoch()}`);\n    break;\n  case GenerateDisposableTokenResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with disposable token scope: ${oneKeyOneCacheToken.errorCode()}: ${oneKeyOneCacheToken.toString()}`\n    );\n}\n\n// Generate a disposable token with read-write access to a specific key prefix in all caches\nconst keyPrefixAllCachesToken = await authClient.generateDisposableToken(\n  DisposableTokenScopes.cacheKeyPrefixReadWrite(AllCaches, 'squirrel'),\n  ExpiresIn.minutes(30)\n);\nswitch (keyPrefixAllCachesToken.type) {\n  case GenerateDisposableTokenResponse.Success:\n    console.log('Generated a disposable API key with access to keys prefixed with \"squirrel\" in all caches!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${keyPrefixAllCachesToken.authToken.substring(0, 10)}`);\n    console.log(`Expires At: ${keyPrefixAllCachesToken.expiresAt.epoch()}`);\n    break;\n  case GenerateDisposableTokenResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with disposable token scope: ${keyPrefixAllCachesToken.errorCode()}: ${keyPrefixAllCachesToken.toString()}`\n    );\n}\n\n// Generate a disposable token with read-only access to all topics in one cache\nconst allTopicsOneCacheToken = await authClient.generateDisposableToken(\n  TokenScopes.topicSubscribeOnly('squirrel', AllTopics),\n  ExpiresIn.minutes(30)\n);\nswitch (allTopicsOneCacheToken.type) {\n  case GenerateDisposableTokenResponse.Success:\n    console.log('Generated a disposable API key with access to all topics in the \"squirrel\" cache!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${allTopicsOneCacheToken.authToken.substring(0, 10)}`);\n    console.log(`Expires At: ${allTopicsOneCacheToken.expiresAt.epoch()}`);\n    break;\n  case GenerateDisposableTokenResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with disposable token scope: ${allTopicsOneCacheToken.errorCode()}: ${allTopicsOneCacheToken.toString()}`\n    );\n}\n\n// Generate a disposable token with write-only access to a single topic in all caches\nconst oneTopicAllCachesToken = await authClient.generateDisposableToken(\n  TokenScopes.topicPublishOnly(AllCaches, 'acorn'),\n  ExpiresIn.minutes(30)\n);\nswitch (oneTopicAllCachesToken.type) {\n  case GenerateDisposableTokenResponse.Success:\n    console.log('Generated a disposable API key with access to all topics in the \"squirrel\" cache!');\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\n    console.log(`API key starts with: ${oneTopicAllCachesToken.authToken.substring(0, 10)}`);\n    console.log(`Expires At: ${oneTopicAllCachesToken.expiresAt.epoch()}`);\n    break;\n  case GenerateDisposableTokenResponse.Error:\n    throw new Error(\n      `An error occurred while attempting to call generateApiKey with disposable token scope: ${oneTopicAllCachesToken.errorCode()}: ${oneTopicAllCachesToken.toString()}`\n    );\n}",python:'response = await auth_client.generate_disposable_token(\n    DisposableTokenScopes.topic_publish_subscribe("a-cache", "a-topic"),\n    ExpiresIn.minutes(5),\n    DisposableTokenProps(token_id="a-token-id"),\n)\nmatch response:\n    case GenerateDisposableToken.Success():\n        print("Successfully generated a disposable token")\n    case GenerateDisposableToken.Error() as error:\n        print(f"Error generating a disposable token: {error.message}")\n\n',java:'final GenerateDisposableTokenResponse response =\n    authClient\n        .generateDisposableTokenAsync(\n            DisposableTokenScopes.cacheKeyReadWrite("squirrel", "mo"), ExpiresIn.minutes(30))\n        .join();\nif (response instanceof GenerateDisposableTokenResponse.Success success) {\n  System.out.println("Successfully generated the disposable token: " + success.authToken());\n} else if (response instanceof GenerateDisposableTokenResponse.Error error) {\n  throw new RuntimeException(\n      "An error occurred while attempting to generate disposable token: "\n          + error.getErrorCode(),\n      error);\n}',kotlin:"",go:'tokenId := "a token id"\nresp, err := authClient.GenerateDisposableToken(ctx, &momento.GenerateDisposableTokenRequest{\n\tExpiresIn: utils.ExpiresInSeconds(10),\n\tScope: momento.TopicSubscribeOnly(\n\t\tmomento.CacheName{Name: "a cache"},\n\t\tmomento.TopicName{Name: "a topic"},\n\t),\n\tProps: momento.DisposableTokenProps{\n\t\tTokenId: &tokenId,\n\t},\n})\n\nif err != nil {\n\tpanic(err)\n}\n\nswitch r := resp.(type) {\ncase *auth_resp.GenerateDisposableTokenSuccess:\n\tlog.Printf("Successfully generated a disposable token for endpoint=%s with tokenId=%s\\n", r.Endpoint, tokenId)\n}',csharp:'// Generate a disposable token with read-write access to a specific key in one cache\r\nvar oneKeyOneCacheToken = await authClient.GenerateDisposableTokenAsync(\r\n    DisposableTokenScopes.CacheKeyReadWrite("squirrels", "mo"),\r\n    ExpiresIn.Minutes(30)\r\n);\r\n\nif (oneKeyOneCacheToken is GenerateDisposableTokenResponse.Success token1)\r\n{\r\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\r\n    Console.WriteLine("The generated disposable token starts with: " + token1.AuthToken.Substring(0, 10));\r\n    Console.WriteLine("The token expires at (epoch timestamp): " + token1.ExpiresAt.Epoch());\r\n}\r\nelse if (oneKeyOneCacheToken is GenerateDisposableTokenResponse.Error err)\r\n{\r\n    Console.WriteLine("Error generating disposable token: " + err.Message);\r\n}\r\n\n// Generate a disposable token with read-write access to a specific key prefix in all caches\r\nvar keyPrefixAllCachesToken = await authClient.GenerateDisposableTokenAsync(\r\n    DisposableTokenScopes.CacheKeyPrefixReadWrite(CacheSelector.AllCaches, "squirrel"),\r\n    ExpiresIn.Minutes(30)\r\n);\r\n\nif (keyPrefixAllCachesToken is GenerateDisposableTokenResponse.Success token2)\r\n{\r\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\r\n    Console.WriteLine("The generated disposable token starts with: " + token2.AuthToken.Substring(0, 10));\r\n    Console.WriteLine("The token expires at (epoch timestamp): " + token2.ExpiresAt.Epoch());\r\n}\r\nelse if (keyPrefixAllCachesToken is GenerateDisposableTokenResponse.Error err)\r\n{\r\n    Console.WriteLine("Error generating disposable token: " + err.Message);\r\n}\r\n\n// Generate a disposable token with read-only access to all topics in one cache\r\nvar allTopicsOneCacheToken = await authClient.GenerateDisposableTokenAsync(\r\n    DisposableTokenScopes.TopicSubscribeOnly("squirrel", TopicSelector.AllTopics),\r\n    ExpiresIn.Minutes(30)\r\n);\r\n\nif (allTopicsOneCacheToken is GenerateDisposableTokenResponse.Success token3)\r\n{\r\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\r\n    Console.WriteLine("The generated disposable token starts with: " + token3.AuthToken.Substring(0, 10));\r\n    Console.WriteLine("The token expires at (epoch timestamp): " + token3.ExpiresAt.Epoch());\r\n}\r\nelse if (allTopicsOneCacheToken is GenerateDisposableTokenResponse.Error err)\r\n{\r\n    Console.WriteLine("Error generating disposable token: " + err.Message);\r\n}\r\n\n// Generate a disposable token with write-only access to a single topic in all caches\r\nvar oneTopicAllCachesToken = await authClient.GenerateDisposableTokenAsync(\r\n    DisposableTokenScopes.TopicPublishOnly(CacheSelector.AllCaches, "acorn"),\r\n    ExpiresIn.Minutes(30)\r\n);\r\n\nif (oneTopicAllCachesToken is GenerateDisposableTokenResponse.Success token4)\r\n{\r\n    // logging only a substring of the tokens, because logging security credentials is not advisable :)\r\n    Console.WriteLine("The generated disposable token starts with: " + token4.AuthToken.Substring(0, 10));\r\n    Console.WriteLine("The token expires at (epoch timestamp): " + token4.ExpiresAt.Epoch());\r\n}\r\nelse if (oneTopicAllCachesToken is GenerateDisposableTokenResponse.Error err)\r\n{\r\n    Console.WriteLine("Error generating disposable token: " + err.Message);\r\n}\r\n',php:"",rust:'  // Basic example\n  let expiry = ExpiresIn::minutes(30);\n  let scope = DisposableTokenScopes::cache_key_read_only(CacheSelector::AllCaches, "key");\n  let response = auth_client\n      .generate_disposable_token(scope, expiry)\n      .await?;\n  let token = response.clone().auth_token();\n  println!(\n      "Generated disposable token ending with \'{}\' that expires at epoch {}", \n      &token[token.len() - 10 .. token.len() - 1], response.expires_at()\n  );\n\n  // Generate a token with optional token ID that can be used with Momento Topics\n  let expiry = ExpiresIn::minutes(30);\n  let scope = DisposableTokenScopes::cache_key_read_only(CacheSelector::AllCaches, "key");\n  let request = GenerateDisposableTokenRequest::new(scope, expiry).token_id("my-token-id".to_string());\n  let response = auth_client.send_request(request).await?;\n  let token = response.clone().auth_token();\n  println!(\n      "Generated disposable token ending with \'{}\' that expires at epoch {}", \n      &token[token.len() - 10 .. token.len() - 1], response.expires_at()\n  );',elixir:"",swift:"",dart:"",ts:""})})]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"permissionscope-objects",children:"PermissionScope objects"}),"\n",(0,o.jsx)(n.h3,{id:"permissionscope",children:"PermissionScope"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Name"}),(0,o.jsx)(n.th,{children:"Type"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"permissions"}),(0,o.jsxs)(n.td,{children:["List <",(0,o.jsx)(n.a,{href:"#permission-objects",children:"Permission"}),">"]}),(0,o.jsx)(n.td,{children:"The permissions to grant to the new token."})]})})]}),"\n",(0,o.jsxs)(n.p,{children:["A PermissionScope is a list of ",(0,o.jsx)(n.a,{href:"#permission-objects",children:"permission objects"}),". The list can have permissions that are of type ",(0,o.jsx)(n.a,{href:"#cachepermission",children:"CachePermission"})," or ",(0,o.jsx)(n.a,{href:"#topicpermission",children:"TopicPermission"}),", and can contain ",(0,o.jsx)(n.a,{href:"/topics/limits",children:"up to ten"})," permission objects. A permission only grants access to the Momento data plane APIs (e.g. ",(0,o.jsx)(n.code,{children:"get"}),", ",(0,o.jsx)(n.code,{children:"set"}),", etc.). When an auth token is created with multiple permission objects, any matching permission will grant access. For example, if a single token is created with two permission objects:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"A permission object that allows ReadWrite access to all caches for the account"}),"\n",(0,o.jsxs)(n.li,{children:["A permission object that allows ReadOnly access to cache ",(0,o.jsx)(n.code,{children:"foo"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In this case, the token will still allow use of data manipulation APIs (e.g. ",(0,o.jsx)(n.code,{children:"set"}),", ",(0,o.jsx)(n.code,{children:"delete"}),", ",(0,o.jsx)(n.code,{children:"DictionarySetFields"}),", etc.) on cache ",(0,o.jsx)(n.code,{children:"foo"})," because of the first permission."]}),"\n",(0,o.jsx)(n.h3,{id:"permission-objects",children:"Permission objects"}),"\n",(0,o.jsxs)(n.p,{children:["These objects define the specific role with cache or topic information and are then assigned to a ",(0,o.jsx)(n.a,{href:"#permissionscope-objects",children:"PermissionScope"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"cachepermission",children:"CachePermission"}),"\n",(0,o.jsxs)(n.p,{children:["A component of a ",(0,o.jsx)(n.a,{href:"#permissionscope-objects",children:"PermissionScope"})," object that defines permissions for a cache."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Name"}),(0,o.jsx)(n.th,{children:"Type"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"role"}),(0,o.jsx)(n.td,{children:"ReadOnly\xa0\xa0|\xa0\xa0ReadWrite\xa0\xa0|\xa0\xa0WriteOnly"}),(0,o.jsx)(n.td,{children:"The type of access granted by the permission."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"cache"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AllCaches"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"CacheName"})]}),(0,o.jsxs)(n.td,{children:["A permission can be restricted to a select cache by name using a ",(0,o.jsx)(n.code,{children:"CacheName"})," object or ",(0,o.jsx)(n.code,{children:"AllCaches"})," built-in value."]})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["For role, using ",(0,o.jsx)(n.code,{children:"CacheRole.ReadOnly"})," allows access to all read data plane APIs on caches (e.g. ",(0,o.jsx)(n.code,{children:"get"}),", ",(0,o.jsx)(n.code,{children:"DictionaryGetField"}),", etc.) defined in the CacheSelector. Using ",(0,o.jsx)(n.code,{children:"CacheRole.ReadWrite"})," allows access for all read and write data plane APIs on the caches defined in the CacheSelector. Using ",(0,o.jsx)(n.code,{children:"CacheRole.WriteOnly"})," allows access for all write data plane APIs on the caches defined in the CacheSelector. ",(0,o.jsx)(n.code,{children:"CacheRole.WriteOnly"})," cannot be used for APIs that imply conditional writes like ",(0,o.jsx)(n.code,{children:"SetIf*"})," or return information about the updated state of a collection e.g. ",(0,o.jsx)(n.code,{children:"ListPushBack"})," returns the new length. Custom roles are not supported."]}),"\n",(0,o.jsxs)(n.p,{children:["For cache, the value can be the built-in ",(0,o.jsx)(n.code,{children:"AllCaches"})," or a string value containing the name of the cache this permission is for."]}),"\n",(0,o.jsx)(n.h4,{id:"permissionscope-example-for-a-cachepermission-object",children:"PermissionScope example for a CachePermission object"}),"\n",(0,o.jsx)(n.p,{children:"This is an example of creating a PermissionScope with just CachePermissions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'const CachePermissions = {\n    permissions: [\n        {\n            role: CacheRole.ReadWrite, // Managed role\n            cache: "MyCache" // grants access to a specific cache\n        },\n        {\n            role: CacheRole.ReadOnly, // Managed role\n            cache: AllCaches // Built-in value for access to all caches in the account.\n        },\n    ],\n};\n'})}),"\n",(0,o.jsx)(n.h3,{id:"topicpermission",children:"TopicPermission"}),"\n",(0,o.jsxs)(n.p,{children:["A component of a ",(0,o.jsx)(n.a,{href:"#permissionscope-objects",children:"PermissionScope"})," object that defines permissions for a token."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Name"}),(0,o.jsx)(n.th,{children:"Type"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"role"}),(0,o.jsx)(n.td,{children:"SubscribeOnly\xa0|\xa0PublishSubscribe\xa0\xa0|\xa0\xa0PublishOnly"}),(0,o.jsx)(n.td,{children:"The type of access granted by the permission."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"cache"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AllCaches"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"CacheName"})]}),(0,o.jsxs)(n.td,{children:["A permission can be restricted to a select cache by name using a ",(0,o.jsx)(n.code,{children:"CacheName"})," object or to all caches in the account by using the ",(0,o.jsx)(n.code,{children:"AllCaches"})," built-in value."]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"topic"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AllTopics"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"TopicName"})]}),(0,o.jsxs)(n.td,{children:["A permission can be restricted to a select topic by name using a ",(0,o.jsx)(n.code,{children:"TopicName"})," object or to all topics in the above cache(s) by using the ",(0,o.jsx)(n.code,{children:"AllTopics"})," built-in value."]})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["For role, there are three managed roles to assign, ",(0,o.jsx)(n.code,{children:"TopicRole.PublishSubscribe"}),", ",(0,o.jsx)(n.code,{children:"TopicRole.SubscribeOnly"}),", and ",(0,o.jsx)(n.code,{children:"TopicRole.PublishOnly"}),". Custom roles are not supported. Using the SubscribeOnly role allows only subscribing to topics, using the PublishSubscribe role allows publishing and subscribing to topics, and using the PublishOnly role allows only publishing to topics."]}),"\n",(0,o.jsxs)(n.p,{children:["For cache, only topics within that cache's namespace are allowed by the permission. This can be set to the built-in ",(0,o.jsx)(n.code,{children:"AllCaches"})," value or a string specifically naming a cache."]}),"\n",(0,o.jsxs)(n.p,{children:["For topic, this can be set to the built-in ",(0,o.jsx)(n.code,{children:"AllTopics"})," value, which gives access to all topics in the cache(s) defined in cache or it can be a string with a specific topic name."]}),"\n",(0,o.jsx)(n.h4,{id:"permissionscope-example-for-a-topicpermission-object",children:"PermissionScope example for a TopicPermission object"}),"\n",(0,o.jsx)(n.p,{children:"This is an example of creating a PermissionScope with just TopicPermissions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const TopicsPermissions = {\n    permissions: [\n      {\n        role: TopicRole.PublishSubscribe, // Managed role\n        cache: 'the-great-wall', // grants access to a specific cache\n        topic: 'highlights', // grants access to a specific topic\n      },\n      {\n        role: TopicRole.SubscribeOnly, // Managed role\n        cache: AllCaches, // This is a built-in value for access to all caches in the account\n        topic: AllTopics, // This is a built-in value for access to all topic in the listed cache(s).\n      },\n    ],\n};\n"})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"disposabletokenscope-objects",children:"DisposableTokenScope objects"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Name"}),(0,o.jsx)(n.th,{children:"Type"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsx)(n.tbody,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"permissions"}),(0,o.jsxs)(n.td,{children:["List <",(0,o.jsx)(n.a,{href:"#disposabletokencachepermissions",children:"DisposableTokenCachePermission"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.a,{href:"#permission-objects",children:"Permission"}),">"]}),(0,o.jsx)(n.td,{children:"The permissions to grant to the new token."})]})})]}),"\n",(0,o.jsxs)(n.p,{children:["The DisposableTokenScope object will accept permissions objects of the type ",(0,o.jsx)(n.a,{href:"#cachepermission",children:"CachePermission"}),", ",(0,o.jsx)(n.a,{href:"#topicpermission",children:"TopicPermission"}),", or ",(0,o.jsx)(n.a,{href:"#disposabletokencachepermissions",children:"DisposableTokenCachePermission"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"disposabletokencachepermissions",children:"DisposableTokenCachePermissions"}),"\n",(0,o.jsxs)(n.p,{children:["The DisposableTokenCachePermission is an extension of CachePermission, so it has the same fields as CachePermission but also has an additional ",(0,o.jsx)(n.code,{children:"item"})," field so you can define permissions for a cache and the items within the cache."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, you can restrict access to only a specific key or a set of keys beginning with some prefix when you set ",(0,o.jsx)(n.code,{children:"item"})," to a string that represents a key or key-prefix. Alternately, if you set ",(0,o.jsx)(n.code,{children:"item"})," to AllCacheItems, you would produce the same set of permissions as a normal CachePermission."]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Name"}),(0,o.jsx)(n.th,{children:"Type"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"role"}),(0,o.jsx)(n.td,{children:"ReadOnly\xa0\xa0|\xa0\xa0ReadWrite\xa0\xa0|\xa0\xa0WriteOnly"}),(0,o.jsx)(n.td,{children:"The type of access granted by the permission."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"cache"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AllCaches"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"CacheName"})]}),(0,o.jsxs)(n.td,{children:["A permission can be restricted to a select cache by name using a ",(0,o.jsx)(n.code,{children:"CacheName"})," object or ",(0,o.jsx)(n.code,{children:"AllCaches"})," built-in value."]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"item"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AllCacheItems"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"Key"}),"\xa0\xa0|\xa0\xa0",(0,o.jsx)(n.code,{children:"KeyPrefix"})]}),(0,o.jsxs)(n.td,{children:["A permission can be restricted to select cache items by name using a ",(0,o.jsx)(n.code,{children:"Key"})," or ",(0,o.jsx)(n.code,{children:"KeyPrefix"})," object or ",(0,o.jsx)(n.code,{children:"AllCachesItems"})," built-in value."]})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["For role, using ",(0,o.jsx)(n.code,{children:"CacheRole.ReadOnly"})," allows access to all read data plane APIs on caches (e.g. ",(0,o.jsx)(n.code,{children:"get"}),", ",(0,o.jsx)(n.code,{children:"DictionaryGetField"}),", etc.) defined in the CacheSelector. Using ",(0,o.jsx)(n.code,{children:"CacheRole.ReadWrite"})," allows access for all read and write data plane APIs on the caches defined in the CacheSelector. Using ",(0,o.jsx)(n.code,{children:"CacheRole.WriteOnly"})," allows access for all write data plane APIs on the caches defined in the CacheSelector. ",(0,o.jsx)(n.code,{children:"CacheRole.WriteOnly"})," cannot be used for APIs that imply conditional writes like ",(0,o.jsx)(n.code,{children:"SetIf*"})," or return information about the updated state of a collection e.g. ",(0,o.jsx)(n.code,{children:"ListPushBack"})," returns the new length. Custom roles are not supported."]}),"\n",(0,o.jsxs)(n.p,{children:["For cache, the value can be the built-in ",(0,o.jsx)(n.code,{children:"AllCaches"})," or a string value containing the name of the cache this permission is for."]}),"\n",(0,o.jsxs)(n.p,{children:["For item, the value can be the built-in ",(0,o.jsx)(n.code,{children:"AllCacheItems"})," or a string value containing the key or key prefix of the cache item(s) this permission is for."]}),"\n",(0,o.jsx)(n.h4,{id:"example-disposabletokenscope-object",children:"Example DisposableTokenScope object"}),"\n",(0,o.jsx)(n.p,{children:"This is an example of creating a DisposableTokenScope with all three types of permission objects: CachePermission, TopicPermission, and DisposableTokenCachePermission."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'const exampleDisposableTokenPermission: DisposableTokenCachePermission = {\n    role: CacheRole.WriteOnly,\n    cache: "WriteCache",\n    item: {\n        keyPrefix: "WriteKey"\n    }\n};\n\nconst exampleCachePermission: CachePermission = {\n    role: CacheRole.ReadOnly,\n    cache: "ReadCache"\n};\n\nconst exampleTopicPermission: TopicPermission = {\n    role: TopicRole.PublishSubscribe,\n    cache: "ReadWriteCache",\n    topic: "MyTopic"\n}\n\nconst exampleScope: DisposableTokenScope = {\n    permissions: [\n        exampleDisposableTokenPermission,\n        exampleCachePermission,\n        exampleTopicPermission,\n    ],\n};\n\n// Then pass in the entire DisposableTokenScope object when\n// you call generateDisposableToken\nconst tokenResponse = await authClient.generateDisposableToken(\n    exampleScope,\n    ExpiresIn.minutes(30)\n);\n'})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Can I create a custom role for a cache or topic permission?"}),(0,o.jsx)(n.p,{children:"No. We only support the managed roles listed above for each permission."})]}),"\n",(0,o.jsxs)(s,{children:[(0,o.jsx)("summary",{children:"Do these tokens control access to the Momento control plane APIs?"}),(0,o.jsxs)(n.p,{children:["Access tokens generated with the ",(0,o.jsx)(n.a,{href:"#generateapikey-api",children:"GenerateApiKey"})," API only control access to the Momento data plane APIs. A token for access to Momento's control plane APIs must be generated using the ",(0,o.jsx)(n.a,{href:"https://console.gomomento.com/",children:"Momento console"}),"."]})]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["If you have any questions not answered here, please jump on ",(0,o.jsx)(n.a,{href:"https://discord.gg/3HkAKjUZGq",children:"our Discord server"})," and ask our experts in the support channel."]})})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},51441:(e,n,s)=>{s(96540)},35347:(e,n,s)=>{s.d(n,{r:()=>k});var o=s(11470),i=s(19365),r=s(21432),t=(s(96540),s(27293)),a=s(74848);const c="https://github.com/momentohq/client-sdk-javascript/blob/main/examples/nodejs/cache/doc-example-files/doc-examples-js-apis.ts",l="https://github.com/momentohq/client-sdk-python/blob/main/examples/py310/doc-examples-python-apis.py",h="https://github.com/momentohq/client-sdk-java/blob/main/examples/cache/src/main/java/momento/client/example/doc_examples/DocExamplesJavaAPIs.java",p="https://github.com/momentohq/client-sdk-kotlin/blob/main/examples/src/main/kotlin/software/momento/example/doc_examples/DocExamples.kt",d="https://github.com/momentohq/client-sdk-go/blob/main/examples/docs-examples/main.go",u="https://github.com/momentohq/client-sdk-dotnet/blob/main/examples/DocExampleApis/Program.cs",m="https://github.com/momentohq/client-sdk-php/blob/main/examples/doc-examples-php-apis.php",x="https://github.com/momentohq/client-sdk-rust/blob/main/example/rust/src/docs_examples/docs_examples.rs",b="https://github.com/momentohq/client-sdk-elixir/blob/main/examples/doc_examples.exs",g="https://github.com/momentohq/client-sdk-swift/blob/main/Examples/doc-example-apis/Sources/main.swift",j="https://github.com/momentohq/client-sdk-dart/blob/main/example/doc_example_apis/bin/doc_example_apis.dart",k=e=>{let{js:n,python:s,java:k,kotlin:y,go:f,csharp:A,php:T,rust:w,ruby:R,elixir:P,swift:C,dart:S,cli:v}=e;return n||s||k||y||f||A||T||w||R||P||C||S||v?(0,a.jsxs)(o.A,{children:[n&&(0,a.jsxs)(i.A,{value:"js",label:"JavaScript",children:[(0,a.jsx)(r.default,{language:"js",children:n}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:c,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),s&&(0,a.jsxs)(i.A,{value:"python",label:"Python",children:[(0,a.jsx)(r.default,{language:"python",children:s}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:l,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),k&&(0,a.jsxs)(i.A,{value:"java",label:"Java",children:[(0,a.jsx)(r.default,{language:"java",children:k}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:h,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),y&&(0,a.jsxs)(i.A,{value:"kotlin",label:"Kotlin",children:[(0,a.jsx)(r.default,{language:"kotlin",children:y}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:p,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),f&&(0,a.jsxs)(i.A,{value:"go",label:"Go",children:[(0,a.jsx)(r.default,{language:"go",children:f}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:d,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),A&&(0,a.jsxs)(i.A,{value:"csharp",label:"C#",children:[(0,a.jsx)(r.default,{language:"csharp",children:A}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:u,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),T&&(0,a.jsxs)(i.A,{value:"php",label:"PHP",children:[(0,a.jsx)(r.default,{language:"php",children:T}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:m,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),w&&(0,a.jsxs)(i.A,{value:"rust",label:"Rust",children:[(0,a.jsx)(r.default,{language:"rust",children:w}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:x,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),R&&(0,a.jsx)(i.A,{value:"ruby",label:"Ruby",children:(0,a.jsx)(r.default,{language:"ruby",children:R})}),P&&(0,a.jsxs)(i.A,{value:"elixir",label:"Elixir",children:[(0,a.jsx)(r.default,{language:"elixir",children:P}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:b,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),C&&(0,a.jsxs)(i.A,{value:"swift",label:"Swift",children:[(0,a.jsx)(r.default,{language:"swift",children:C}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:g,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),S&&(0,a.jsxs)(i.A,{value:"dart",label:"Dart",children:[(0,a.jsx)(r.default,{language:"dart",children:S}),(0,a.jsxs)(t.A,{type:"info",children:["Full example code and imports can be found ",(0,a.jsx)("a",{href:j,target:"_blank",rel:"noopener noreferrer",children:"here"})]})]}),v&&(0,a.jsx)(i.A,{value:"cli",label:"CLI",children:(0,a.jsx)(r.default,{language:"cli",children:v})})]}):null}}}]);