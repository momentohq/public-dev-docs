"use strict";(globalThis.webpackChunkmomento_docs=globalThis.webpackChunkmomento_docs||[]).push([[2620],{22707:(e,n,t)=>{t.d(n,{A:()=>k});var a=t(96540),r=t(34164),i=t(79872),o=t(44319),c=t(56347),s=t(94280),l=t(73024),d=t(58417),u=t(44031);function h(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return h(e).map((({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a})))}(t);return function(e){const n=(0,d.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function v({queryString:e=!1,groupId:n}){const t=(0,c.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(r),(0,a.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function g(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,i=m(e),[o,c]=(0,a.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:i}))),[l,d]=v({queryString:t,groupId:r}),[h,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,u.Dv)(n);return[t,(0,a.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:r}),b=(()=>{const e=l??h;return p({value:e,tabValues:i})?e:null})();(0,s.A)((()=>{b&&c(b)}),[b]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),g(e)}),[d,g,i]),tabValues:i}}var b=t(46916);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var y=t(74848);function x({className:e,block:n,selectedValue:t,selectValue:a,tabValues:i}){const c=[],{blockElementScrollPositionUntilNextRender:s}=(0,o.a_)(),l=e=>{const n=e.currentTarget,r=c.indexOf(n),o=i[r].value;o!==t&&(s(n),a(o))},d=e=>{let n=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,y.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:i.map((({value:e,label:n,attributes:a})=>(0,y.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{c.push(e)},onKeyDown:d,onClick:l,...a,className:(0,r.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function j({lazy:e,children:n,selectedValue:t}){const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=i.find((e=>e.props.value===t));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,y.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function I(e){const n=g(e);return(0,y.jsxs)("div",{className:(0,r.A)(i.G.tabs.container,"tabs-container",f.tabList),children:[(0,y.jsx)(x,{...n,...e}),(0,y.jsx)(j,{...n,...e})]})}function k(e){const n=(0,b.A)();return(0,y.jsx)(I,{...e,children:h(e.children)},String(n))}},23224:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>u});const a=JSON.parse('{"id":"media-storage/concurrency/account-level","title":"Concurrency tracking","description":"Learn how to track and manage concurrent devices for an account","source":"@site/docs/media-storage/concurrency/account-level.md","sourceDirName":"media-storage/concurrency","slug":"/media-storage/concurrency/account-level","permalink":"/media-storage/concurrency/account-level","draft":false,"unlisted":false,"editUrl":"https://github.com/momentohq/public-dev-docs/tree/main/docs/media-storage/concurrency/account-level.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Device management","title":"Concurrency tracking","description":"Learn how to track and manage concurrent devices for an account","hide_title":true,"keywords":["momento","media storage","zero buffer rate","zbr","streaming","live","elemental","serverless","metrics","concurrency tracking"]},"sidebar":"mediastorageSidebar","previous":{"title":"Concurrency"},"next":{"title":"Device management","permalink":"/media-storage/concurrency/devices"}}');var r=t(74848),i=t(28453),o=t(22707),c=t(53632);const s={sidebar_position:2,sidebar_label:"Device management",title:"Concurrency tracking",description:"Learn how to track and manage concurrent devices for an account",hide_title:!0,keywords:["momento","media storage","zero buffer rate","zbr","streaming","live","elemental","serverless","metrics","concurrency tracking"]},l="Tracking concurrent devices for an account",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Building a concurrency tracker",id:"building-a-concurrency-tracker",level:2},{value:"Token vending machine",id:"token-vending-machine",level:3},{value:"Device heartbeat",id:"device-heartbeat",level:3},{value:"Heartbeat handler",id:"heartbeat-handler",level:3},{value:"Concurrency checker",id:"concurrency-checker",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tracking-concurrent-devices-for-an-account",children:"Tracking concurrent devices for an account"})}),"\n",(0,r.jsxs)(n.p,{children:["Tracking concurrent devices or streams per account is essential for applications where managing access, ensuring security, and optimizing resources are top priorities. In subscription-based services, enforcing device or stream limits restrict simultaneous access to content to a specified number of devices. ",(0,r.jsx)(n.strong,{children:"Concurrency tracking"})," also supports account security by preventing unauthorized sharing, safeguarding the service from potential misuse. This also enables resource optimization in high-traffic applications, especially within media and entertainment, by managing resources dynamically based on real-time demand."]}),"\n",(0,r.jsxs)(n.p,{children:["The pattern outlined below demonstrates how Momento provides ",(0,r.jsx)(n.strong,{children:"real-time session monitoring"})," without the need for complex infrastructure."]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.mermaid,{value:'flowchart TD\n    subgraph Account\n        A[Account ID]\n    end\n    subgraph Momento\n        B1[Store Heartbeats in Cache Dictionary]\n        B2[Evaluate Unique Devices on Entitlement Check]\n    end\n    subgraph Device\n        C1[Device 1]\n        C2[Device 2]\n        C3[Device N]\n    end\n\n    C1 -- "Heartbeat \u27a1 Session ID + Timestamp" --\x3e B1\n    C2 -- "Heartbeat \u27a1 Session ID + Timestamp" --\x3e B1\n    C3 -- "Heartbeat \u27a1 Session ID + Timestamp" --\x3e B1\n\n    B1 -- "Capped to Most Recent N Entries" --\x3e B2\n    A -- "Evaluate Active Concurrency" --\x3e B2\n\n    Account -.->|Check Entitlement| A'}),"\n",(0,r.jsxs)(n.p,{children:["Monitoring concurrency with Momento relies on ",(0,r.jsx)(n.a,{href:"/media-storage/enhancements/heartbeats",children:"heartbeats"})," to be emitted from connected players. A server component manages ",(0,r.jsx)(n.a,{href:"/cache/develop/basics/datatypes#dictionaries",children:"cache dictionaries"})," in Momento that track the heartbeats from unique players over a given interval. During an ",(0,r.jsx)(n.a,{href:"/media-storage/entitlements/about",children:"entitlement check"}),", the last ",(0,r.jsx)(n.em,{children:"complete"})," interval dictionary is fetched and the concurrency count is determined."]}),"\n",(0,r.jsx)(n.p,{children:"The major components in concurrency tracking are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Device"})," - Each device or stream sends a heartbeat via ",(0,r.jsx)(n.a,{href:"/topics",children:"Momento Topics"}),", which includes a unique session ID."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Momento"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cache"})," - Stores recent heartbeats for each account in interval based cache dictionaries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Auth"})," - Creates ",(0,r.jsx)(n.a,{href:"/cache/develop/authentication/tokens",children:"session tokens"})," for players, encoding the account id directly in the token."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Account"})," - Represents the user account in your system."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"building-a-concurrency-tracker",children:"Building a concurrency tracker"}),"\n",(0,r.jsx)(n.p,{children:"Four components are needed in this pattern"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Token vending machine"}),"\n",(0,r.jsx)(n.li,{children:"Device heartbeat"}),"\n",(0,r.jsx)(n.li,{children:"Heartbeat handler"}),"\n",(0,r.jsx)(n.li,{children:"Concurrency checker"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"token-vending-machine",children:"Token vending machine"}),"\n",(0,r.jsx)(n.p,{children:"A token vending machine is a pattern that dispenses short-lived session tokens with limited permissions. This is a server-side component, usually an API endpoint, that dynamically generates the token. Below is a snippet of code used to create a session token. This code should live inside of your API endpoint handler."}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(c.A,{value:"node",label:"Node.js",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const scope = { permissions: [\n  {\n    role: 'publishonly',\n    cache: 'video',\n    topic: 'heartbeat'\n  }\n]};\n\nconst response = await authClient.generateDisposableToken(scope, ExpiresIn.minutes(30), { tokenId: accountId });\nif(response.type === GenerateDisposableTokenResponse.Success){\n  return { token: response.authToken };\n}\n"})})}),(0,r.jsx)(c.A,{value:"go",label:"Go",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'resp, err := authClient.GenerateDisposableToken(ctx, &momento.GenerateDisposableTokenRequest{\n\t\tExpiresIn: utils.ExpiresInMinutes(30),\n\t\tScope: momento.TopicPublishOnly(\n\t\t\tmomento.CacheName{Name: "video"},\n\t\t\tmomento.TopicName{Name: "heartbeat"},\n\t\t),\n\t\tProps: momento.DisposableTokenProps{\n\t\t\tTokenId: &req.PlayerID,\n\t\t},\n\t})\n\n\tif err != nil {\n\t\thttp.Error(w, "Failed to generate token", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n  switch r := resp.(type) {\n\tcase *auth_resp.GenerateDisposableTokenSuccess:\n\t\treturn r.ApiKey\n\tdefault:\n\t\thttp.Error(w, "Failed to generate token", http.StatusInternalServerError)\n\t}\n'})})}),(0,r.jsx)(c.A,{value:"dotnet",label:".NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'var response = await _authClient.GenerateDispableTokenAsync(\n  DisposableTokenScopes.TopicPublishOnly("video", "heartbeat"),\n  ExpiresIn.Minutes(30)\n);\n\nreturn response.AuthToken;\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["In the snippet above, we set explicit permissions to allow the user to ",(0,r.jsx)(n.em,{children:"publish"})," messages to the ",(0,r.jsx)(n.code,{children:"heartbeat"})," topic. This is the way the player heartbeat will communicate with our handler. The token is configured to live for 30 minutes and has the user's ",(0,r.jsx)(n.code,{children:"accountId"})," embedded in the token. The embedded account id will show up as an argument in our heartbeat subscription on the server, ",(0,r.jsx)(n.em,{children:"preventing messages from being spoofed"})," and adding a layer of security to our solution."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"In a production scenario, this code might live in your existing authZ mechanism and return the generated token as a claim. Assumptions are made here that prior to the code snippet above, the user has been authenticated and you have access to their account id and have securely identified the content their are attempting to view."})}),"\n",(0,r.jsx)(n.h3,{id:"device-heartbeat",children:"Device heartbeat"}),"\n",(0,r.jsx)(n.p,{children:"With the token vending machine in place, we can use it on the device to publish heartbeat on a regular interval. The heartbeat can contain any information about the media, player, or device based on your use case. For this simple walkthrough, we will provide the minimum amount of information and include only the device id."}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(c.A,{value:"sdk",label:"Momento Web SDK (React)",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import React, { useEffect, useState, useMemo } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { TopicClient, CredentialProvider } from '@gomomento/sdk-web';\n\nconst HEARTBEAT_INTERVAL_MS = 5000;\n\nfunction getMediaIdFromQuery() {\n  const params = new URLSearchParams(window.location.search);\n  return params.get('id');\n}\n\nfunction Device() {\n  const [topicClient, setTopicClient] = useState(null);\n\n  const mediaId = useMemo(() => getMediaIdFromQuery(), []);\n  const deviceId = useMemo(() => {\n    const savedDeviceId = localStorage.getItem('deviceId');\n    if (savedDeviceId) return savedDeviceId;\n\n    const newDeviceId = crypto.randomUUID();\n    localStorage.setItem('deviceId', newDeviceId);\n    return newDeviceId;\n  }, []);\n\n  const message = useMemo(() => JSON.stringify({ deviceId, mediaId }), [deviceId, mediaId]);\n\n  useEffect(() => {\n    async function initTopicClient() {\n      const response = await fetch('http://localhost:3000/tokens', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ accountId: 'account-id' }),\n      });\n      if (response.ok) {\n        const { token } = await response.json();\n        const topicClient = new TopicClient({\n          credentialProvider: CredentialProvider.fromString(token),\n        });\n        setTopicClient(topicClient);\n      }\n    }\n\n    initTopicClient();\n  }, [mediaId]);\n\n  useEffect(() => {\n    if (topicClient) {\n      const intervalId = setInterval(() => {\n        topicClient.publish('video', 'heartbeat', message);\n      }, HEARTBEAT_INTERVAL_MS);\n\n      return () => clearInterval(intervalId);\n    }\n  }, [topicClient, mediaId, message]);\n\n  return (\n    <div>\n      <h2>Device {deviceId}: {topicClient ? 'Connected' : 'Not Connected'}</h2>\n    </div>\n  );\n}\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(<Device />);\n\n"})})}),(0,r.jsx)(c.A,{value:"http",label:"HTTP only",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n\n<body>\n  <div id=\"root\">\n    <h2>Device <span id=\"deviceId\"></span>: <span id=\"status\">Not Connected</span></h2>\n  </div>\n\n  <script>\n    const HEARTBEAT_INTERVAL_MS = 5000;\n    const mediaId = getMediaIdFromQuery();\n    const deviceId = getDeviceId();\n    const message = JSON.stringify({ deviceId, mediaId });\n    let token;\n\n    function getMediaIdFromQuery() {\n      const params = new URLSearchParams(window.location.search);\n      return params.get('id');\n    }\n\n    function getDeviceId() {\n      let deviceId = localStorage.getItem('deviceId');\n      if (!deviceId) {\n        deviceId = crypto.randomUUID();\n        localStorage.setItem('deviceId', deviceId);\n      }\n\n      document.getElementById('deviceId').innerText = deviceId;\n      return deviceId;\n    }\n\n    async function sendHeartbeat() {\n      await fetch(`<MOMENTO_REGION_ENDPOINT>/topics/video/heartbeat`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': token\n        },\n        body: message,\n      });\n    }\n\n    async function getToken() {\n      const response = await fetch('http://localhost:3000/tokens', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ accountId: 'account-id' }),\n      });\n\n      if (response.ok) {\n        const { token } = await response.json();\n        return token;\n      }\n    }\n\n    function startHeartbeat() {\n      setInterval(() => {\n        sendHeartbeat();\n      }, HEARTBEAT_INTERVAL_MS);\n    }\n\n    async function init() {\n      const statusElement = document.getElementById('status');\n      token = await getToken();\n      if (token) {\n        statusElement.innerText = 'Connected';\n        startHeartbeat();\n      } else {\n        statusElement.innerText = 'Failed to Connect';\n      }\n    }\n\n    init();\n  <\/script>\n</body>\n</html>\n\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["In the above examples, the player html only includes the heartbeat logic. It calls the token vending machine from step one that we put behind an API endpoint running locally to fetch a token. Once the player has the token, it begins publishing the device id and media id to the ",(0,r.jsx)(n.code,{children:"heartbeat"})," topic. The heartbeat is sent every 5 seconds so the heartbeat handler can track active instances."]}),"\n",(0,r.jsx)(n.p,{children:"Two things to note in the code for the device heartbeat:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"The account id being supplied to the token vending machine is hardcoded, in practice this would come from your AuthN mechanism."}),"\n",(0,r.jsxs)(n.li,{children:["When calling the Momento HTTP API, the base url is ",(0,r.jsx)(n.a,{href:"/platform/regions",children:"region based"}),". Substitute the placeholder with the correct region endpoint for your use case. If you use the Momento SDK, region handling is managed for you."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["For a complete example of a token vending machine, ",(0,r.jsx)(n.a,{href:"/media-storage/enhancements/live-reactions#step-1-building-a-token-vending-machine",children:"check out this tutorial"}),"."]})}),"\n",(0,r.jsx)(n.h3,{id:"heartbeat-handler",children:"Heartbeat handler"}),"\n",(0,r.jsx)(n.p,{children:"Devices for a specific account will be tracked in a series of cache dictionaries. A unique cache dictionary will be used to track device heartbeats over a given time interval. The time interval can vary based on your business requirements. Our example will be evaluating concurrency once a minute."}),"\n",(0,r.jsxs)(n.p,{children:["The naming convention for the interval-based dictionaries is ",(0,r.jsx)(n.code,{children:"{accountId}-${intervalTime}"}),". To calculate the interval time, get the time in ticks of a given minute and round down."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(c.A,{value:"node",label:"Node.js",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function getIntervalMarker(minutesBack = 0) {\n  const now = new Date();\n  now.setTime(now.getTime() - minutesBack * 60000);\n  now.setSeconds(0, 0);\n  return now.getTime();\n}\n"})})}),(0,r.jsx)(c.A,{value:"go",label:"Go",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'import (\n\t"fmt"\n\t"time"\n)\n\nfunc getIntervalMarker(minutesBack int) int64 {\n\tnow := time.Now().Add(-time.Duration(minutesBack) * time.Minute)\n\trounded := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), 0, 0, now.Location())\n\treturn rounded.UnixNano() / int64(time.Millisecond)\n}\n'})})}),(0,r.jsx)(c.A,{value:"dotnet",label:".NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"static long GetIntervalMarker(int minutesBack = 0)\n{\n  DateTime now = DateTime.UtcNow.AddMinutes(-minutesBack);\n  now = new DateTime(now.Year, now.Month, now.Day, now.Hour, now.Minute, 0, DateTimeKind.Utc);\n  return new DateTimeOffset(now).ToUnixTimeMilliseconds();\n}\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"To create the cache key that tracks the device heartbeat count, you append the value from the function above to the end of a user's account id. Creating keys this way means you have a dedicated cache item per interval. Coupled with an appropriate TTL, the cache item will clean itself up automatically, simplifying the code needed for the pattern."}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(c.A,{value:"node",label:"Node.js",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Get the account id through your business logic\nconst accountId = getAccountId(req);\nconst { deviceId } = req.body;\nconst key = `${accountId}-${getIntervalMarker()}`;\n\nawait cacheClient.dictionaryIncrement('video', key, deviceId, 1);\n"})})}),(0,r.jsx)(c.A,{value:"go",label:"Go",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'accountId := getAccountId(req)\ndeviceId := req.DeviceID\n\nkey := fmt.Sprintf("%s-%d", accountId, getIntervalMarker())\n_, err := cacheClient.DictionaryIncrement(ctx, &momento.DictionaryIncrementRequest{\n  CacheName:      momento.String("video"),\n  DictionaryName: key,\n  Field:          deviceId,\n  Amount:         1\n})\nif err != nil {\n  fmt.Println("Error incrementing cache:", err)\n}\n'})})}),(0,r.jsx)(c.A,{value:"dotnet",label:".NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'  var accountId = GetAccountId(req);\n  var deviceId = req.Body.DeviceId;\n  var key = $"{accountId}-{getIntervalMarker()}";\n\n  await cacheClient.DictionaryIncrementAsync("video", key, deviceId, 1);\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["As heartbeats come in, the device id is stored as a value in the dictionary and a count is incremented. A ",(0,r.jsx)(n.a,{href:"/cache/learn/how-it-works/expire-data-with-ttl",children:"time to live (TTL)"})," is set on the dictionary for twice the interval length, so the data automatically cleans itself up when it is no longer needed."]}),"\n",(0,r.jsx)(n.h3,{id:"concurrency-checker",children:"Concurrency checker"}),"\n",(0,r.jsxs)(n.p,{children:["Lastly, we have the concurrency checker. Often rolled in as part of an ",(0,r.jsx)(n.a,{href:"/media-storage/entitlements/about",children:"entitlement check"}),", this is the logic that reads the heartbeat dictionary and determines if an account is over their allowed limit. To check concurrency, we fetch the dictionary length from the ",(0,r.jsx)(n.em,{children:"previous interval"})," and count the number of entries."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(c.A,{value:"node",label:"Node.js",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async function getConcurrentDeviceCount(accountId) {\n  const interval = getIntervalMarker(1);\n  const intervalKey = `${accountId}-${interval}`;\n  let deviceCount = 0;\n  const response = await cacheClient.dictionaryLength('video', intervalKey);\n  if(response.type === CacheDictionaryLengthResponse.Hit){\n    deviceCount = response.value();\n  }\n  return deviceCount;\n}\n"})})}),(0,r.jsx)(c.A,{value:"go",label:"Go",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'func getConcurrentDeviceCount(accountId string) int {\n  interval := getIntervalMarker(1)\n\tintervalKey := fmt.Sprintf("%s-%d", accountId, interval)\n\tdeviceCount := 0\n\n\tresp, err := client.DictionaryLength(ctx, &momento.DictionaryLengthRequest{\n\t\tCacheName:      momento.String("video"),\n\t\tDictionaryName: intervalKey,\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tswitch r := resp.(type) {\n\tcase *responses.DictionaryLengthHit:\n\t\tdeviceCount = int(r.Length())\n\t}\n\treturn deviceCount\n}\n'})})}),(0,r.jsx)(c.A,{value:"dotnet",label:".NET",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'static async Task<int> GetConcurrentDeviceCount(CacheClient cacheClient, string accountId)\n{\n  long interval = GetIntervalMarker(1);\n  string intervalKey = $"{accountId}-{interval}";\n  int deviceCount = 0;\n\n  CacheDictionaryLengthResponse response = await cacheClient.DictionaryLengthAsync("video", intervalKey);\n  if (response is CacheDictionaryLengthResponse.Hit)\n  {\n    deviceCount = response.Length;\n  }\n\n  return deviceCount;\n}\n'})})})]}),"\n",(0,r.jsxs)(n.p,{children:["This function uses the ",(0,r.jsx)(n.code,{children:"getIntervalMarker"})," method we created in the previous step to get the time of our last interval, then calls Momento Cache to see how many entries are in the dictionary. Remember, each device that reported a heartbeat counts as an entry in the dictionary, so the length directly maps to the number of concurrent players."]}),"\n",(0,r.jsx)(n.p,{children:"The value is returned to the caller and it's up to standard business logic to take over from there."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["For a complete example of this pattern in action, along with other practical patterns for media streaming, check out our ",(0,r.jsx)(n.a,{href:"https://github.com/momentohq/demo-video-streaming",children:"demo on GitHub"}),"!"]})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var a=t(96540);const r={},i=a.createContext(r);function o(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(i.Provider,{value:n},e.children)}},53632:(e,n,t)=>{t.d(n,{A:()=>o});t(96540);var a=t(34164);const r={tabItem:"tabItem_Ymn6"};var i=t(74848);function o({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,t),hidden:n,children:e})}}}]);